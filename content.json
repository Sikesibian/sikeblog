{"pages":[{"title":"About","text":"随意留言。","link":"about/index.html"},{"title":"404","text":"","link":"404/index.html"},{"title":"Tags","text":"","link":"tags/index.html"},{"title":"Untagged","text":"","link":"tags/Untagged.html"},{"title":"","text":"","link":"links/links.html"}],"posts":[{"title":"关于代数学习一些很酷的网站","text":"查资料：Math StackExchange (MSE) 话不多说 群论的神：Finite groups 特征标表：Character tables 线性群：Linear and projective linear groups 多项式的Galois群：Transitive groups of degree up to 31 # sagemath K.&lt;a&gt; = NumberField(POLYNOMIAL) G = K.galois_group() print(G)","link":"2025/01/07/Algebra-0/"},{"title":"计算复杂性作业笔记","text":"1. 图灵机 1. 图灵可判定 已知 ATM={⟨M,ω⟩∣M 为图灵机且接受ω}\\text{A}_{\\text{TM}} = \\left\\{ \\langle M, \\omega \\rangle \\mid M\\text{ 为图灵机且接受} \\omega \\right\\}ATM​={⟨M,ω⟩∣M 为图灵机且接受ω} 不可判定，请证明： HALTTM={⟨M,ω⟩∣M 为图灵机且 M在输入为 ω 时停机}\\text{HALT}_{\\text{TM}} = \\left\\{ \\langle M, \\omega \\rangle \\mid M\\text{ 为图灵机且 } M \\text{在输入为 } \\omega \\text{ 时停机} \\right\\}HALTTM​={⟨M,ω⟩∣M 为图灵机且 M在输入为 ω 时停机} 不可判定 ETM={⟨M,ω⟩∣M 为图灵机且 L(M)=∅}\\text{E}_{\\text{TM}} = \\left\\{ \\langle M, \\omega \\rangle \\mid M\\text{ 为图灵机且 } L(M)=\\emptyset \\right\\}ETM​={⟨M,ω⟩∣M 为图灵机且 L(M)=∅} 不可判定 REGULARTM={⟨M⟩∣M 为图灵机且 L(M) 为一个正则语言}\\text{REGULAR}_{\\text{TM}} = \\left\\{ \\langle M \\rangle \\mid M\\text{ 为图灵机且 } L(M) \\text{ 为一个正则语言} \\right\\}REGULARTM​={⟨M⟩∣M 为图灵机且 L(M) 为一个正则语言} 不可判定 EQTM={⟨M1,M2⟩∣M1,M2 均为图灵机且 L(M1)=L(M2)}\\text{EQ}_{\\text{TM}} = \\left\\{ \\langle M_1, M_2 \\rangle \\mid M_1, M_2 \\text{ 均为图灵机且 } L(M_1) = L(M_2) \\right\\}EQTM​={⟨M1​,M2​⟩∣M1​,M2​ 均为图灵机且 L(M1​)=L(M2​)} 不可判定 1. 证明 HALTTM={⟨M,ω⟩∣M 为图灵机且 M在输入为 ω 时停机}\\text{HALT}_{\\text{TM}} = \\left\\{ \\langle M, \\omega \\rangle \\mid M\\text{ 为图灵机且 } M \\text{在输入为 } \\omega \\text{ 时停机} \\right\\}HALTTM​={⟨M,ω⟩∣M 为图灵机且 M在输入为 ω 时停机} 不可判定 证明：反证法，假设上述语言可判定，设其其中一个判定器为 RRR，则可以构建如下判定器 SSS ： S=&quot;对输入 ⟨M,ω⟩(1)对于输入 ⟨M,ω⟩ 运行图灵机 R(2)如果 R 拒绝，则拒绝(3)如果 R 接受，则模拟图灵机 M 在输入为 ω 时的运行，直至停机(4)如果 M 接受，则接受；若 M 拒绝，则拒绝&quot;\\begin{aligned} &amp;S = \\text{&quot;对输入 } \\langle M, \\omega \\rangle\\\\ &amp;\\qquad (1) \\text{对于输入 } \\langle M, \\omega \\rangle \\text{ 运行图灵机 } R\\\\ &amp;\\qquad (2) \\text{如果 } R \\text{ 拒绝，则拒绝}\\\\ &amp;\\qquad (3) \\text{如果 } R \\text{ 接受，则模拟图灵机 } M \\text{ 在输入为 } \\omega \\text{ 时的运行，直至停机}\\\\ &amp;\\qquad (4) \\text{如果 } M \\text{ 接受，则接受；若 } M \\text{ 拒绝，则拒绝&quot;}\\\\ \\end{aligned} ​S=&quot;对输入 ⟨M,ω⟩(1)对于输入 ⟨M,ω⟩ 运行图灵机 R(2)如果 R 拒绝，则拒绝(3)如果 R 接受，则模拟图灵机 M 在输入为 ω 时的运行，直至停机(4)如果 M 接受，则接受；若 M 拒绝，则拒绝&quot;​ 由此可见，若 RRR 可以判定 HALTTM\\text{HALT}_{\\text{TM}}HALTTM​ ，则 SSS 也可以判定 ATM\\text{A}_{\\text{TM}}ATM​ ，但由于 ATM\\text{A}_{\\text{TM}}ATM​ 不可判定，所以矛盾。 因此 HALTTM\\text{HALT}_{\\text{TM}}HALTTM​ 不可判定。 2. 证明 ETM={⟨M,ω⟩∣M 为图灵机且 L(M)=∅}\\text{E}_{\\text{TM}} = \\left\\{ \\langle M, \\omega \\rangle \\mid M\\text{ 为图灵机且 } L(M)=\\emptyset \\right\\}ETM​={⟨M,ω⟩∣M 为图灵机且 L(M)=∅} 不可判定 证明：反证法，假设上述语言可判定，设其其中一个判定器为 RRR，则可以构建一个入后所示的判定器 SSS 。在构建 SSS 之前将构造一个特殊的图灵机 M1M_1M1​ ，使得 M1M_1M1​ 能保证拒绝除 ω\\omegaω 外的所有字符串，而对于输入 ω\\omegaω 则正常运行。 具体 M1M_1M1​ 构造如下： M1=&quot;对输入 x(1)若 x≠ω 则拒绝 (2)若 x=ω 则接受&quot;\\begin{aligned} &amp;M_1 = &quot;\\text{对输入 } x\\\\ &amp;\\qquad (1) \\text{若 } x\\neq \\omega \\text{ 则拒绝 }\\\\ &amp;\\qquad (2) \\text{若 } x=\\omega \\text{ 则接受}&quot;\\\\ \\end{aligned} ​M1​=&quot;对输入 x(1)若 x​=ω 则拒绝 (2)若 x=ω 则接受&quot;​ 这样的图灵机 M1M_1M1​ 最多只能接受 ω\\omegaω ，其识别的语言非空当且仅当 MMM 能够接受 ω\\omegaω。这里 M1M_1M1​ 将 ω\\omegaω 视为其描述的一部分，它扫描输入 xxx 一测试 xxx 是否与 www 相同。这时我们把 M1M_1M1​ 作为 RRR 的输入就可以构造出如下的判定器 SSS ： S=&quot;对输入 ⟨M,ω⟩(1)利用 ⟨M,ω⟩ 来构造出上面方法（算法）所描述构造出的 M1(3)对输入 ⟨M1⟩ 运行图灵机 R(4)如果 R 接受，则拒绝；若 R 拒绝，则接受&quot;\\begin{aligned} &amp;S = &quot;\\text{对输入 } \\langle M, \\omega \\rangle\\\\ &amp;\\qquad (1) \\text{利用 } \\langle M, \\omega \\rangle \\text{ 来构造出上面方法（算法）所描述构造出的 } M_1\\\\ &amp;\\qquad (3) \\text{对输入 } \\langle M_1 \\rangle \\text{ 运行图灵机 } R\\\\ &amp;\\qquad (4) \\text{如果 } R \\text{ 接受，则拒绝；若 } R \\text{ 拒绝，则接受}&quot;\\\\ \\end{aligned} ​S=&quot;对输入 ⟨M,ω⟩(1)利用 ⟨M,ω⟩ 来构造出上面方法（算法）所描述构造出的 M1​(3)对输入 ⟨M1​⟩ 运行图灵机 R(4)如果 R 接受，则拒绝；若 R 拒绝，则接受&quot;​ 这样就证明了，若 RRR 可以判定 ETM\\text{E}_{\\text{TM}}ETM​ ，则 SSS 也可以判定 ATM\\text{A}_{\\text{TM}}ATM​ ，但由于 ATM\\text{A}_{\\text{TM}}ATM​ 不可判定，所以矛盾。 因此 ETM\\text{E}_{\\text{TM}}ETM​ 不可判定。 3. REGULARTM={⟨M⟩∣M 为图灵机且 L(M) 为一个正则语言}\\text{REGULAR}_{\\text{TM}} = \\left\\{ \\langle M \\rangle \\mid M\\text{ 为图灵机且 } L(M) \\text{ 为一个正则语言} \\right\\}REGULARTM​={⟨M⟩∣M 为图灵机且 L(M) 为一个正则语言} 不可判定 证明：反证法，假设上述语言可判定，设其其中一个判定器为 RRR，则可以构建如下判定器 SSS ： S=&quot;对输入 ⟨M,ω⟩(1)首先构造如下图灵机 M1M1=&quot;对输入的字符串 x[1]若 x 是 0n1n 形式的，那么接受；[2]若 x 不具有上述形式，那么将 ω 输入 M ，若 M接受 ω 则接受。 &quot;(2)将 ⟨M1⟩ 输入 R(3)如果 R 接受，则接受；若 R 拒绝，则拒绝&quot;\\begin{aligned} &amp;S = \\text{&quot;对输入 } \\langle M, \\omega \\rangle\\\\ &amp;\\qquad (1) \\text{首先构造如下图灵机 } M_1\\\\ &amp;\\qquad M_1 = &quot;\\text{对输入的字符串 } x \\\\ &amp;\\qquad\\qquad [1] \\text{若 } x \\text{ 是 } 0^n1^n \\text{ 形式的，那么接受；}\\\\ &amp;\\qquad\\qquad [2] \\text{若 } x \\text{ 不具有上述形式，那么将 } \\omega \\text{ 输入 } M \\text{ ，若 } M \\text{接受 } \\omega \\text{ 则接受。 } &quot;\\\\ &amp;\\qquad (2) \\text{将 } \\langle M_1\\rangle \\text{ 输入 } R\\\\ &amp;\\qquad (3) \\text{如果 } R \\text{ 接受，则接受；若 } R \\text{ 拒绝，则拒绝&quot;}\\\\ \\end{aligned} ​S=&quot;对输入 ⟨M,ω⟩(1)首先构造如下图灵机 M1​M1​=&quot;对输入的字符串 x[1]若 x 是 0n1n 形式的，那么接受；[2]若 x 不具有上述形式，那么将 ω 输入 M ，若 M接受 ω 则接受。 &quot;(2)将 ⟨M1​⟩ 输入 R(3)如果 R 接受，则接受；若 R 拒绝，则拒绝&quot;​ 上述机器利用了一个先验知识，即语言 {0n1n∣n⩾0}\\left\\{ 0^n1^n\\mid n\\geqslant 0 \\right\\}{0n1n∣n⩾0} 是非正则的，且 {{0n1n∣n⩾0}M 不接受 ωΣ∗M 接受 ω\\begin{cases}\\left\\{ 0^n1^n\\mid n\\geqslant 0 \\right\\} &amp;M\\text{ 不接受 }\\omega\\\\\\Sigma^*&amp;M\\text{ 接受 }\\omega\\end{cases}{{0n1n∣n⩾0}Σ∗​M 不接受 ωM 接受 ω​。从而根据上述构造，利用判定器 RRR 可以推断出 L(M1)L(M_1)L(M1​) 是否为正则语言，也意味着能够判定 MMM 能否接受 ω\\omegaω ，即得 ATM\\text{A}_{\\text{TM}}ATM​ 的判定器 SSS，矛盾。 因此 REGULARTM\\text{REGULAR}_{\\text{TM}}REGULARTM​ 不可判定。 4. EQTM={⟨M1,M2⟩∣M1,M2 均为图灵机且 L(M1)=L(M2)}\\text{EQ}_{\\text{TM}} = \\left\\{ \\langle M_1, M_2 \\rangle \\mid M_1, M_2 \\text{ 均为图灵机且 } L(M_1) = L(M_2) \\right\\}EQTM​={⟨M1​,M2​⟩∣M1​,M2​ 均为图灵机且 L(M1​)=L(M2​)} 不可判定 证明：反证法，假设上述语言可判定，设其其中一个判定器为 RRR，则可以构建如下判定器 SSS ： S=&quot;对输入 ⟨M,ω⟩(1)构造图灵机 M′，且 L(M′)=∅，即 M′ 拒绝一切输入(2)将 ⟨M,M′⟩ 输入 R(3)如果 R 接受，则接受；若 R 拒绝，则拒绝&quot;\\begin{aligned} &amp;S = \\text{&quot;对输入 } \\langle M, \\omega \\rangle\\\\ &amp;\\qquad (1) \\text{构造图灵机 } M'\\text{，且 } L(M')=\\emptyset\\text{，即 } M' \\text{ 拒绝一切输入}\\\\ &amp;\\qquad (2) \\text{将 } \\langle M, M'\\rangle \\text{ 输入 } R\\\\ &amp;\\qquad (3) \\text{如果 } R \\text{ 接受，则接受；若 } R \\text{ 拒绝，则拒绝&quot;}\\\\ \\end{aligned} ​S=&quot;对输入 ⟨M,ω⟩(1)构造图灵机 M′，且 L(M′)=∅，即 M′ 拒绝一切输入(2)将 ⟨M,M′⟩ 输入 R(3)如果 R 接受，则接受；若 R 拒绝，则拒绝&quot;​ 即得 ATM\\text{A}_{\\text{TM}}ATM​ 的判定器 SSS，矛盾。 因此 EQTM\\text{EQ}_{\\text{TM}}EQTM​ 不可判定。 2. 图灵可识别 证明 EQTM\\text{EQ}_{\\text{TM}}EQTM​ 不是图灵可识别的，也不是补图灵可识别的。 引理：A⩽mB ⟺ A‾⩽mB‾A\\leqslant_{m} B \\iff \\overline{A} \\leqslant_m \\overline{B}A⩽m​B⟺A⩽m​B 引理的证明：若A⩽mBA\\leqslant_m BA⩽m​B，则即 ∃f:Σ∗→Σ∗\\exists f:\\Sigma^* \\rightarrow \\Sigma^*∃f:Σ∗→Σ∗， ∀ω,ω∈A ⟺ f(ω)∈B\\forall\\omega, \\omega\\in A\\iff f(\\omega)\\in B ∀ω,ω∈A⟺f(ω)∈B 也就有 ∀ω,ω∉A ⟺ f(ω)∉B\\forall\\omega, \\omega\\not\\in A\\iff f(\\omega)\\not\\in B ∀ω,ω​∈A⟺f(ω)​∈B 则： A⩽mB⇒A‾⩽mB‾A\\leqslant_m B\\Rightarrow \\overline{A}\\leqslant_m \\overline{B} A⩽m​B⇒A⩽m​B 另一方面，将 A‾\\overline{A}A 和 B‾\\overline{B}B 分别作为上述的AAA和BBB 带入，则也得到： A‾⩽mB‾⇒A⩽mB\\overline{A}\\leqslant_m \\overline{B} \\Rightarrow A\\leqslant_m B A⩽m​B⇒A⩽m​B 综上所述，A‾⩽mB‾ ⟺ A⩽mB\\overline{A}\\leqslant_m \\overline{B} \\iff A\\leqslant_m BA⩽m​B⟺A⩽m​B 原命题的证明： 【步骤一】将 ATM‾\\overline{\\text{A}_{\\text{TM}}}ATM​​ 归约到 EQTM\\text{EQ}_{\\text{TM}}EQTM​ ，从而说明 EQTM\\text{EQ}_{\\text{TM}}EQTM​ 不是图灵可识别的。 构造可计算函数如下： F=&quot;对输入 ⟨M,ω⟩(1)构造图灵机 ⟨M1,M2⟩ 其中：M1=对任何输入均拒绝M2=对任何输入，将 ω 输入 M，若 M接受这接受(2)输出 ⟨M1,M2⟩&quot;\\begin{aligned} &amp;F = &quot;\\text{对输入 } \\langle M, \\omega\\rangle\\\\ &amp;\\qquad (1) \\text{构造图灵机 } \\langle M_1, M_2 \\rangle \\text{ 其中：}\\\\ &amp;\\qquad\\qquad M_1 = \\text{对任何输入均拒绝}\\\\ &amp;\\qquad\\qquad M_2 = \\text{对任何输入，将 }\\omega\\text{ 输入 } M \\text{，若 } M \\text{接受这接受}\\\\ &amp;\\qquad (2) \\text{输出 } \\langle M_1, M_2 \\rangle&quot; \\end{aligned} ​F=&quot;对输入 ⟨M,ω⟩(1)构造图灵机 ⟨M1​,M2​⟩ 其中：M1​=对任何输入均拒绝M2​=对任何输入，将 ω 输入 M，若 M接受这接受(2)输出 ⟨M1​,M2​⟩&quot;​ 这里的 F:Σ∗→Σ∗F:\\Sigma^* \\rightarrow \\Sigma^*F:Σ∗→Σ∗ 是可计算的，且 ∀x=⟨M,ω⟩\\forall x=\\langle M, \\omega\\rangle∀x=⟨M,ω⟩，有 x∈ATM‾ ⟺ F(x)∈EQTMx\\in\\overline{\\text{A}_{\\text{TM}}} \\iff F(x)\\in\\text{EQ}_{\\text{TM}}x∈ATM​​⟺F(x)∈EQTM​，因此 ATM‾⩽mEQTM\\overline{\\text{A}_{\\text{TM}}}\\leqslant_m \\text{EQ}_{\\text{TM}}ATM​​⩽m​EQTM​。 由 ATM‾\\overline{\\text{A}_{\\text{TM}}}ATM​​ 不是图灵可识别的可知，EQTM\\text{EQ}_{\\text{TM}}EQTM​ 也不是图灵可识别的。 【步骤二】证明 EQTM‾\\overline{\\text{EQ}_{\\text{TM}}}EQTM​​ 也不是图灵可识别的。（利用 ATM⩽mEQTM ⟺ ATM‾⩽mEQTM‾\\text{A}_{\\text{TM}} \\leqslant_m \\text{EQ}_{\\text{TM}} \\iff \\overline{\\text{A}_{\\text{TM}}} \\leqslant_m \\overline{\\text{EQ}_{\\text{TM}}}ATM​⩽m​EQTM​⟺ATM​​⩽m​EQTM​​ ） 构造与【步骤一】类似的可计算函数 F′F'F′，其中F′F'F′ 恰将 FFF 中的 M1M_1M1​ 修改为 M1=对任何输入都接受M_1=\\text{对任何输入都接受}M1​=对任何输入都接受，则有 F′F'F′ 对 ∀x=⟨M,ω⟩\\forall x=\\langle M, \\omega \\rangle∀x=⟨M,ω⟩ 有 x∈ATM ⟺ F′(x)∈EQTMx\\in \\text{A}_{\\text{TM}} \\iff F'(x)\\in \\text{EQ}_{\\text{TM}}x∈ATM​⟺F′(x)∈EQTM​。因此： ATM⩽mEQTM\\text{A}_{\\text{TM}} \\leqslant_m \\text{EQ}_{\\text{TM}} ATM​⩽m​EQTM​ 利用引理，也就有： ATM‾⩽mEQTM‾\\overline{\\text{A}_{\\text{TM}}} \\leqslant_m \\overline{\\text{EQ}_{\\text{TM}}} ATM​​⩽m​EQTM​​ 由于 ATM‾\\overline{\\text{A}_{\\text{TM}}}ATM​​ 不是图灵可识别的，从而 EQTM‾\\overline{\\text{EQ}_{\\text{TM}}}EQTM​​ 也不是图灵可识别的。 【综上所述】命题得证。","link":"2025/01/11/CCC-0/"},{"title":"Lean4-0 —— Lean4 的安装","text":"下一篇：Lean4-1 —— Lean4 的基本使用 VSCode 中安装 Lean 4 VSCode中安装扩展： 跟随右侧导航走即可： 记得给 elan 设置一下环境变量，elan 一般在这个文件夹下（C:\\User\\&lt;User Name&gt;\\.elan\\bin\\）： 编写一个测试文件： 点击右侧 ∀\\forall∀ 符号，选择 Toggle Infoview 可以看到一些预览信息（或快捷键 Ctrl+Shift+Enter： Lean 4 项目的创建 我们使用 lake 进行项目的创建 注（引用自：Lean4 - Mathlib4 / 用于形式化数学的准备 (1) - 知乎，Lean4 安装教程 - Lean Prover 中文文档）： lake：Lean 4 的包管理器，全称 Lean Make，已合并到 Lean 4 仓库，作为源码的一部分。它用于创建 Lean 项目，构建 Lean 包，配置 Mathlib 和编译 Lean 可执行文件。 elan：Lean 环境版本管理器。它的功能类似于 Rust 的 rustup 或 Node.js 的 nvm，用于安装、管理和切换不同版本的 Lean。 然后可以使用以下命令进行项目 lake new basic 这样就建立了一个名为 basic 的项目，它的结构是这样的： basic ├─ Basic │ └─ Basic.lean ├─ Basic.lean ├─ lake-manifest.json ├─ lakefile.toml ├─ lean-toolchain ├─ Main.lean └─ README.md 或者你也可以选择在某个文件夹下直接运行 lake init 进行初始化。 接下来就可以使用 lake 来将 Lean 4 程序转换为可执行程序了： lake build 你观察项目文件目录结构会发现恰好多了一个 ./lake 文件夹。接下来就是运行： lake exec hello 总结 lake 常见用法如下所示： # 构建新项目 lake new &lt;project_name&gt; # 在当前文件夹初始化新项目 lake init # 构建项目可执行文件 lake build # 运行 lake exec &lt;project_name&gt; # 清理构建文件 lake clean # 更新依赖 lake update # 运行 lakefile.lean 的脚本 lake run &lt;script&gt; 包的引用 注意到初始化好的项目中有一个文件 leanfile.toml ，这是一个配置文件，我们可以在其中进行引用的管理，格式如下： # A Reservoir dependency [[require]] name = &quot;&lt;pkg-name&gt;&quot; scope = &quot;&lt;scope&gt;&quot; version = &quot;&lt;version&gt;&quot; options = {&lt;options&gt;} # A path dependency [[require]] name = &quot;&lt;pkg-name&gt;&quot; path = &quot;&lt;path&gt;&quot; # A Git dependency [[require]] name = &quot;&lt;pkg-name&gt;&quot; git = &quot;&lt;url&gt;&quot; rev = &quot;&lt;rev&gt;&quot; subDir = &quot;&lt;subDir&gt;&quot; 其中比如我们想要引用 Mathlib，那么就可以如下编辑 leanfile.toml 文件： name = &quot;basic&quot; version = &quot;0.1.0&quot; defaultTargets = [&quot;basic&quot;] [[lean_lib]] name = &quot;Basic&quot; [[lean_exe]] name = &quot;basic&quot; root = &quot;Main&quot; [[require]] name = &quot;mathlib&quot; git = &quot;https://github.com/leanprover-community/mathlib4.git&quot; rev = &quot;v4.11.0&quot; 注意把 lean-toolchain 内容改为： leanprover/lean4:v4.11.0 （等价于 curl -L https://raw.githubusercontent.com/leanprover-community/mathlib4/master/lean-toolchain -o lean-toolchain） 如果你是 leanfile.lean，则在文件中添加：require mathlib from git &quot;https://github.com/leanprover-community/mathlib4&quot; 即可。 当然你也可以选择在安装项目的时候使用指令： lake +leanprover-community/mathlib4:lean-toolchain new &lt;your_project_name&gt; math 这时运行 lake update ，额，它就会疯狂安装包。 下面这个命令可以下载预编译的文件： 这样build就很快：","link":"2024/11/29/Lean4-0/"},{"title":"Lean4-1 —— Lean4 的基本使用","text":"上一篇：Lean4-0 —— Lean4 的安装 这里假定大家有一定C语言、Python基础。 注释：单行注释：-- 注释，多行注释：/- 多行注释 -/。下面的代码中会使用注释来标记代码的解释说明或者Lean的返回结果。Lean是很方便的，它往往能实时向我们返回结果。 1. Lean4 中的声明、检查与求值 下面先列出对应的关键字： 声明（Define） def：用于声明一个新的常量 检查（Check） #check：用于检查一个对象的类型 求值（Evaluate） #eval：用于计算给出的表达式 以井号开头的都是用于向Lean系统询问信息的辅助命令，比如这里的 #check 和 #eval。 例子： /- 定义常数 -/ def m : Nat := 1 def b : Bool := true /- 检查类型 -/ #check m #check b /- 求值 -/ #eval m + 6 #eval b &amp;&amp; false 2. Lean4 的基本使用 Lean中的任意表达式都有一个类型。 Lean是用于构建复杂表达式的工具，基于 依值类型论（Dependent Type Theory） 这一形式语言。 2.0 依值类型论 类型论是一类基于 λ\\lambdaλ 演算的形式理论的统称，所有数学对象都有各自的类型。而依值类型论是一种类型的定义可以依赖于值（由值所推断）的类型论，可以写成： Γ⊢A type\\Gamma \\vdash A\\text{ type} Γ⊢A type 依值类型论的一些概念并不容易理解，但是我们可以将依值类型论和我们熟知的数理逻辑作如下对应（但不能完全等同）： 数理逻辑 依值类型论 语境 语境 命题 类型 命题宇宙 宇宙 全称量词 Π\\PiΠ 类型（积类型） 存在量词 Σ\\SigmaΣ 类型（和类型） 语境：相继式 ⊢\\vdash⊢ 左边的部分，也称上下文或先决条件。 类型：类似于集合，但与集合不同。类型直接通过规则定义。 宇宙：可以理解为“类型的类型”，虽然这样并不准确。 Σ\\SigmaΣ 类型：定义的一种新类型，类似于将类型合并整合成一个新类型。如C语言中的联合体。 Π\\PiΠ 类型：定义的一种新类型，展现出来的类型随输入实例类型变化。如C语言中的结构体。 2.1 Lean4 编程基础 万物皆函数。 2.1.1 Lean4 的 “Hello, World!” 函数的形式 在我们学习C语言等高级语言时，函数往往都写成 func(x) 的形式，而在 Lean （或 Haskell、Lisp 等）语言中朋友们应当习惯直接将参数写在函数后面： #eval String.append &quot;Hello, &quot; &quot;World!&quot; 实际上实现的效果就是：String.append(&quot;Hello, &quot;, &quot;World&quot;)，但是这样写语法并不正确，所以这里用一根删除线划掉 当然你也可以类似 Python 点号标记来调用函数的写法： #eval &quot;Hello, &quot;.append &quot;World!&quot; 这样的函数也是有一定执行顺序的，比如对比下面两个语句： -- #eval String.append String.append &quot;Hello&quot; &quot;, &quot; &quot;world!&quot; （不可执行） #eval String.append (String.append &quot;Hello&quot; &quot;, &quot;) &quot;world!&quot; -- #eval String.append &quot;Hello&quot; String.append &quot;, &quot; &quot;world!&quot; （不可执行） #eval String.append &quot;Hello&quot; (String.append &quot;, &quot; &quot;world!&quot;) 而这个函数的值就是这个表达式所计算出来的值。 条件表达式（ITE表达式） ITE表达式即 If-Then-Else 表达式，实际上就类似于 C语言 中的三目运算符 ; ? 或 Python 中的 &lt;statement1&gt; if &lt;condition&gt; else &lt;statement2&gt; ，那么在Lean中就有： #eval String.append &quot;Oh! &quot; (if 1 &gt; 2 then &quot;Yes!&quot; else &quot;No!&quot;) --&gt; #eval String.append &quot;Oh! &quot; (if false then &quot;Yes!&quot; else &quot;No!&quot;) --&gt; #eval String.append &quot;Oh! &quot; &quot;No!&quot; --&gt; &quot;Oh! No!&quot; 定义 功能 例子 效果 定义常量 def YES := &quot;Yes!&quot; #eval String.append &quot;Oh! &quot; YES 定义函数（单元） def succ1 (n : Nat) : Nat := n + 1 #eval succ1 6 定义函数（多元） def succk (n : Nat) (k : Nat) : Nat := n + k #eval succk 3 6 定义类型（类似于 typedef ） def Str : Type := String def HELLO : Str := &quot;Hello, World!&quot; 注：Nat 表示自然数，Type 表示“类型的类型” 不过可能遇到下面这个问题，首先定义： def NaturalNum : Type := Nat 那么下面这段代码就会报错： def sixteen : NatrualNum := 16 -- Wrong! 这是因为 16 被认为是歧义的，我们需要指定右边 16 的类型，即重载（Overload）： def sixteen : NatrualNum := (16 : Nat) -- Right! 当然你也可以使用 abbrev 关键字来解决这个问题： abbrev NNNNat : Type := Nat def sixteen' : NNNNat := 16 而像 abbrev 生成的定义会被标记为可约（Reducible）定义，即可展开的定义，而当我们完全展开所有定义可能会产生十分大的类型（正如第一小节依值类型论所涉及到的），控制这种可约定义对 Lean 的灵活性有着关键作用。 2.1.2 柯里化（Currying） 柯里化指的是把接受多个参数的函数转换成接受单个参数的函数，可以理解为每接受一个参数就产生一个新函数，即逐个带入函数的参数（即使用返回函数的函数来实现多参数函数），以数学家哈斯克尔·柯里（Haskell Curry）命名。柯里化能够一定程度上解决重复传参问题，提高函数适用性。 在Python中考虑这样形式的函数（虽然我们并不建议使用Python中lambda表达式语法糖）： add3 = lambda x, y, z: x + y + z 柯里化后会形如： add3_ = lambda x: lambda y: lambda z: x + y + z 这里Python中 add3(1, 2, 3) 就与 add3_(1)(2)(3) 一致。 下面来谈谈 Lean 中的柯里化。观察下面这个多元输入函数： def mycurrying (n : Nat) (k : String) : Int := n + (String.length k) 使用 #check 语句，用小括号来包裹住函数名称使其显示函数类型，得到如下结果： #check (mycurrying) -- mycurrying : Nat → String → Int #check (mycurrying 3) -- mycurrying 3 : String → Int #check (mycurrying 3 &quot;Hello&quot;) -- mycurrying 3 &quot;Hello&quot; : Int 第一行 mycurrying 是一个接受自然数和字符串，返回整数的函数。类型表示为 Nat → String → Int，表示函数依次接受一个自然数和字符串，最后返回一个整数。 第二行 mycurrying 3 表达式整体被视为一个接受字符串，返回整数的函数。类型表示为 String → Int，表示函数依次接受一个字符串，最后返回一个整数。 第三行 mycurrying 3 &quot;Hello&quot; 表示在提供了所有参数 3 和 &quot;Hello&quot; 之后，mycurrying 函数的类型。此时，它直接返回一个整数 Int。 Lean4 中，函数的柯里化是默认的，也就是说，函数的参数是从左到右的，而函数的返回值是从右到左即右结合的（即 Nat → String → Int 所表达的就是 Nat → (String → Int) ，即 Nat 返回一个 String → Int 的函数）。 如果我们把类型看做命题，那么只有接受了正确类型的值（类型由值推导），才能获得下一步的函数，也就是说我们可以把其中连接类型的箭头 → 看做蕴含或者推导符号。 2.1.3 数据类型 Lean 基本类型：Nat, Int, String, Char, Bool, Float, … Lean 标准库内置类型：List（链表），Option（可选类型），Prod（积类型），Sum（和类型），Unit（单位类型），Empty（空类型）… 自定义数据类型：Structure（结构体），Inductive（归纳类型）… 在这一篇中我们主要只介绍 structure 和 inductive 两种类型。更多内容，包括多态（Polymorphism），将在后续文章中进行介绍。 结构体（Structure） 下面以平面坐标的一个点为例。一个平面坐标中的点由 x和 y两个坐标唯一确定，因此可以通过下面的Lean代码构建这样的一个表示平面坐标中点的结构体： structure Point where x : Float y : Float structure 关键字定义了一个新的数据类型，其中 x 和 y 是结构体的字段，它们是结构体中包含的数据。如果你希望在 #eval 的时候能够显示求值结果，那么请在上述代码后面加上 deriving Repr（类似于Python 的 __repr__ 函数）。即： structure Point where x : Float y : Float deriving Repr deriving Repr 是一个 Lean4 的关键字，它表示在结构体中定义的每个字段都会被自动生成一个 Repr 实例，即 Repr 实例会自动生成一个 toString 方法，该方法会将结构体中的每个字段转换为字符串，并使用逗号分隔。 A. 创建结构体类型值 直接创建：def P1 : Point := { x := 1.0, y := 2.0 } 构造子（Constructor）：收集要存储在新分配的数据结构中的数据，如上面 Point 结构体的构造子是 Point.mk 这个默认名称。上面直接创建的方式，就等价于 def P1 : Point := Point.mk 1.0 2.0。而若要覆盖默认名称 mk，则需要写成如下形式： structure Point where newpoint :: x : Float y : Float B. 访问结构体字段 点号表记法：访问 x 和 y 字段：P1.x 和 P1.y 例子，点的欧氏距离函数： def distance (p1 p2 : Point) : Float := Float.sqrt ((p2.x - p1.x) ^ 2.0 + (p2.y - p1.y) ^ 2.0) C. 结构体更新 更新在 Lean 中其实与其在其他语言中含义并不太一样，在其他语言中这意味着对应的内存位置被新的值覆盖，但是Lean 是没有可变状态的，即说明 Lean 中的更新相当于分配了一个新的 Point （在此例中）。 使用 with 关键字来替换结构体中的一些字段，例子如下： def updateX (p : Point) (x' : Float) : Point := { p with x := x'} -- 等价于 def updateX' (p : Point) (x' : Float) : Point := { x := x', y := p.y } 再次注意，Lean 中结构体的更新并没有修改原有结构体实例的值。 和类型、递归类型（Recursive Type）、归纳类型（Inductive Type） Σ\\SigmaΣ 类型/和类型：可以理解为可以选择的类型 递归类型：可以包含自身实例的类型。 归纳类型：递归类型 + 和类型 下面就是一个归纳类型的例子，它表示一个图形，可以是一个点，也可以是直线，也可以是圆。 inductive Shape where | point : Point → Shape | line : Point → Point → Shape | circle : Point → Float → Shape deriving Repr -- 加上使得我们能够 #eval 它 下面是一个使用的例子： #check Shape -- Shape : Type #eval Shape.circle origin 3.0 -- 也相当于 #eval Shape.circle (Point.mk 0.0 0.0) 3.0 Lean 中使用**模式匹配（Pattern Matching）**来处理一些诸如类型判断，然后分别处理等任务。如下例子所示： def area (s : Shape) : Float := match s with | Shape.point _ =&gt; 0.0 | Shape.line _ _ =&gt; 0.0 | Shape.circle _ r =&gt; Pi * r * r where Pi := 3.141592653589793 match 关键字根据模式来匹配一个值，然后执行相应的代码块。这里代码的意义就是，match 判断 s 属于 Shape 中的哪一类： Shape.point，则返回 0.0 Shape.line，则返回 0.0 Shape.circle，则返回 Pi * r * r，其中 Pi 是一个局部变量，r 是 Shape.circle 中的一个字段。 而这里的 _ 相当于一个参数的占位符，往往用于表示忽略该字段。where 关键字定义了一个局部变量，它只在当前函数内部可见。 值得一提的是，Lean 提供了不少简洁的写法，比如上面的 area 函数和下面这个 area' 函数是等价的： def area' : Shape → Float | Shape.point _ =&gt; 0.0 | Shape.line _ _ =&gt; 0.0 | Shape.circle _ r =&gt; Pi * r * r where Pi := 3.141592653589793 你可以对多变元函数的某个变元进行匹配： def PointOnCircle (c : Shape) (p : Point) : Prop := match c with | Shape.circle o r =&gt; (p.x - o.x) ^ 2 + (p.y - o.y) ^ 2 = r ^ 2 | _ =&gt; false 也可以对多变元函数的多个变元进行匹配： def PointOnLine (l : Shape) (p : Point) : Prop := match l with | Shape.line p1 p2 =&gt; (p.x - p1.x) * (p2.y - p1.y) - (p.y - p1.y) * (p2.x - p1.x) = 0 | _ =&gt; false 这里的两个函数 PointOnCircle 和 PointOnLine 与我们刚刚定义的函数有点不同，它们是无法 #eval 的，这是因为它们返回的是一个 Proposition，即一个命题类型（Prop），而命题无法求值。 匿名函数 Lean中也允许函数不在顶层被定义，它允许定义一种被称为匿名函数（anonymous function）的东西，使用的是关键字 fun 或者 λ。 如下面这个例子： #check fun x : Nat =&gt; x + 1 -- fun x =&gt; x + 1 : Nat → Nat #check λ x : Nat =&gt; x + 1 -- fun x =&gt; x + 1 : Nat → Nat 事实上匿名函数的使用方式和一般的 def 所定义的函数完全一致，就是没有函数名的函数。 下面是一个更加复杂一点的例子： #check λ hpc : PointOnCircle (Shape.circle origin 5.0) (Point.mk 3.0 4.0) =&gt; sorry 这里函数变量 hpc 的类型就是 PointOnCircle (Shape.circle origin 5.0) (Point.mk 3.0 4.0)的实例化，虽然后面使用了 sorry 来作为占位符，但实际上 =&gt;后面我们就可以使用 hpc 这个变量，来表示 hpc 这个命题了。 证明一个定理 在上一部分中其实还有许许多多可以聊的内容，但是我想在这里可以聊一聊如何利用Lean 来证明一个定理。 回忆一下，我们说，Lean 中的类型与数理逻辑中的命题相对应，Lean 通过对类型的推断来证明定理。 在本篇内容的前半部分，我们定义了下面几个东西： #check Point -- Point : Type #check Shape -- Shape : Type #check PointOnCircle -- PointOnCircle (c : Shape) (p : Point): Prop #check (PointOnCircle) -- PointOnCircle : Shape → Point → Prop #check PointOnLine -- PointOnLine (l : Shape) (p : Point): Prop #check (PointOnLine) -- PointOnLine : Shape → Point → Prop 下面我们证明一个定理： 若一个点在一个圆上，且这个点也在一条直线上，则该点同时在直线和圆上。 注：其实这里就是一个重言式的例子，不过为了方便，我们给了它这样的一个情境。 定理的描述 将上述命题在 Lean 中表达出来即： theorem PointOnCircleOnLine (c : Shape) (l : Shape) (p : Point) : PointOnCircle c p → PointOnLine l p → PointOnCircle c p ∧ PointOnLine l p := sorry theorem 关键字定义了一个定理，它和 def 的区别在于，theorem 直接是一个不可求值的命题，而 def 是一个可求值的函数。 另外，sorry 是一个占位符，表示我们暂时还没有证明这个命题。 假设 theorem 的名字是 PointOnCircleOnLine，那么 PointOnCircleOnLine 的内容就被视为一个命题，而 PointOnCircleOnLine c l p 就是一个命题的实例。如下所示： #check PointOnCircleOnLine Lean Infoview中反馈到我们： PointOnCircleOnLine (c l : Shape) (p : Point) : PointOnCircle c p → PointOnLine l p → PointOnCircle c p ∧ PointOnLine l p 传入一个参数 Shape.circle (Point.mk 0.0 0.0) 3.0： #check PointOnCircleOnLine (Shape.circle (Point.mk 0.0 0.0) 3.0) 注：柯里化。 Lean Infoview中反馈到我们： PointOnCircleOnLine (Shape.circle { x := 0.0, y := 0.0 } 3.0) : ∀ (l : Shape) (p : Point), PointOnCircle (Shape.circle { x := 0.0, y := 0.0 } 3.0) p → PointOnLine l p → PointOnCircle (Shape.circle { x := 0.0, y := 0.0 } 3.0) p ∧ PointOnLine l p 定理的证明 数学上大致证明过程如下： theorem PointOnCircleOnLine (c : Shape) (l : Shape) (p : Point) : PointOnCircle c p → PointOnLine l p → PointOnCircle c p ∧ PointOnLine l p := -- 假设 p 在 c 上，并且 p 在 l 上 -- 证明 p 在 c 和 l 上 -- 证明完成 sorry 在 Lean4 中它所对应的代码就如下所示： theorem PointOnCircleOnLine (c : Shape) (l : Shape) (p : Point) : PointOnCircle c p → PointOnLine l p → PointOnCircle c p ∧ PointOnLine l p := -- 假设 p 在 c 上，并且 p 在 l 上 λ hpc : PointOnCircle c p =&gt; λ hpl : PointOnLine l p =&gt; have hp : PointOnCircle c p := hpc have hl : PointOnLine l p := hpl -- 证明 p 在 c 和 l 上 show PointOnCircle c p ∧ PointOnLine l p -- 证明目标 from And.intro hp hl -- 证明过程 -- 证明完成 λ 关键字：表示一个 lambda 表达式/匿名函数，是Lean中未在顶层定义的函数，可以理解为就是一个表达式。Lean中 的 λ 关键字 和 fun 是一致的，虽然你常常看到的是 fun。 hpc 和 hpl：表示 hpc 是 PointOnCircle c p 的一个实例，表示对应的命题 PointOnCircle c p，而 hpl 是 PointOnLine l p 的一个实例，亦表示了对应的命题 PointOnLine l p。 have 关键字：用来引入一个新的局部假设或结论的关键字。在证明中，可以使用 have 来声明一个中间步骤，然后这个步骤就可以在后面被引用。比如这里的 have hp : PointOnCircle c p := hpc，hp 就是一个局部假设，它表示 hpc 的值。 show 关键字：用来明确指出证明的目标类型的关键字。这里 show PointOnCircle c p ∧ PointOnLine l p 就指出证明的目标是展示点同时在圆上和线上。 from 关键字：用来指定证明过程的关键字。这里 from And.intro hp hl 就使用 And.intro 证明了点同时在圆上和线上。 And.intro：用来构造一个 PointOnCircle c p ∧ PointOnLine l p 的值，同时也就证明了我们需要的命题。 让我们回顾一些理解关键点： Lean 中 Prop 类型和数理逻辑中的命题相对应。值和类型可以看做是等价的（依值类型）。 函数的参数（的类型）可以看做初始条件；函数的返回值（的类型）可以看做目标条件。比如上述例子中的 PointOnCircle c p → PointOnLine l p →，PointOnCircle c p 和 PointOnLine l p 都是初始条件，而 PointOnCircle c p ∧ PointOnLine l p 是目标条件。 我们根据给到的传入参数值构造新的中间变量，这些中间变量的类型就是我们产生的中间命题。 have 关键字可以引入新的局部假设或结论，而 show 关键字可以明确指出证明的目标类型，from 关键字则可以指定证明过程。 更进一步 如果进一步定义两个图形的交点： def Intersects (c1 c2 : Shape) (p : Point) : Prop := match c1, c2 with | Shape.circle _ _, Shape.circle _ _ =&gt; PointOnCircle c1 p ∧ PointOnCircle c2 p | Shape.circle _ _, Shape.line _ _ =&gt; PointOnCircle c1 p ∧ PointOnLine c2 p | Shape.line _ _, Shape.circle _ _ =&gt; PointOnCircle c2 p ∧ PointOnLine c1 p | Shape.line _ _, Shape.line _ _ =&gt; PointOnLine c1 p ∧ PointOnLine c2 p | _, _ =&gt; false 前面证明的定理的描述可以转换为： 若一个点在一个圆上，且这个点也在一条直线上，则该点为直线和圆的交点。 类似地可以给出如下定理及其证明： theorem PointOnCircleOnLine' (c : Shape) (l : Shape) (p : Point) : PointOnCircle c p → PointOnLine l p → -- 条件：假设 p 在 c 上，并且 p 在 l 上 Intersects c l p := -- 目标：证明 p 是 c 和 l 的交点 λ hpc : PointOnCircle c p =&gt; -- 实例化条件 hpc：p 在 c 上 λ hpl : PointOnLine l p =&gt; -- 实例化条件 hpl：p 在 l 上 have hp : PointOnCircle c p := hpc -- 引入新的局部假设 hp，由 hpc 诱导出 have hl : PointOnLine l p := hpl -- 引入新的局部假设 hl，由 hpl 诱导出 match c, l with -- 匹配 c 和 l 的类型，确保其在后续使用 Intersects 的时候具体类型是匹配的 | Shape.circle o1 r1, Shape.line p1 p2 =&gt; -- 匹配到 c 和 l 的具体类型 show Intersects (Shape.circle o1 r1) (Shape.line p1 p2) p from -- 证明目标 And.intro hp hl -- 证明过程，构造一个 PointOnCircle c p ∧ PointOnLine l p 的值，其与 Intersects c l p 类型一致，也就证明了这个命题 这里我们并不能直接使用 show Intersects c l p，因为 Lean4 的 show 关键字只能显式地指明目标类型，而 Intersects c l p 的类型是隐式地推导出来的，所以需要显示地指明。即 Lean4 会认为这里的 c, l 的类型是 Shape，而非期待的 Shape.circle 和 Shape.line。","link":"2024/12/07/Lean4-1/"},{"title":"关于 校内CTF比赛 UCATFLAGS 2024 出的一些题","text":"本次比赛是笔者主导发起的、学校本科的第一场本科部级的CTF比赛，笔者共出了 5 个Welcome题目，1 个 Pwn题（UAF+堆管理），3.5 个 Misc （1 个 AI模型题、1 个音频隐写、1 个文件格式题、0.5 个社会工程题）和 6 个 Crypto。下面给出其中两个 Crypto 题目的解题思路。 Challenge Type Solutions Points Keywords MyLittlePoly Crypto 12 250 多项式的计算、最大公因数 EzPrime Crypto 11 250 RSA算法+小规模爆破+解二次方程 AfterStory Crypto 8 300 已知明文攻击+LFSR状态泄露 BabyDLog Crypto 6 400 Pohlig-Hellman 算法的深入理解 GoldenYear Crypto 0 500 椭圆曲线点群阶数、LSB搜索、同余方程 Latte Crypto 0 500 AGCD、背包+离散对数 IAmFree! Pwn 3 350 简单的UAF + 堆管理 BigConcert Misc 11 200 简单的音频声道隐写、摩斯电码 backdoor Misc 6 300 简单的DNN模型项目代码理解 easypicture Misc 16 300 简单的文件格式分析 GoldenYear 题干代码 2024年的玉泉路是金黄色的，将满是回忆。 GoldenYear.sage # sagemath from Crypto.Util.number import * from os import urandom from Flag import FLAG, MAXLEN New_Year = 2024 FLAG = FLAG + urandom(MAXLEN - len(FLAG)) # Verify the Goldbach's Conjecture Goldbach_christian = [(p, New_Year - p) for p in sieve_base if p &lt;= New_Year // 2 and isPrime(New_Year - p)] # 2024 is a Leap Year! Happy_2024, Haqqy_2024 = getPrime(New_Year // 4), getPrime(New_Year // 4) while (Happy_2024 % 3 == Haqqy_2024 % 3): Happy_2024 = getPrime(New_Year // 4) Hanny_2024 = Happy_2024 * Haqqy_2024 # The exuberant new year of 2024 will bring us joy and excitement! p, q = choice(Goldbach_christian) Exuberant_p = EllipticCurve(GF(Happy_2024), [0, p]) Exuberant_q = EllipticCurve(GF(Haqqy_2024), [0, q]) # Happy New Year! m = bytes_to_long(FLAG) with open(r&quot;./output.txt&quot;, &quot;w&quot;) as f: gift1 = bytes_to_long(str(Exuberant_p.order() + q).encode()) * bytes_to_long(str(Haqqy_2024 + p).encode()) gift2 = bytes_to_long(str(Happy_2024 + q).encode()) * bytes_to_long(str(Exuberant_q.order() + p).encode()) print(f&quot;I'll give the gifts to U: {Hanny_2024, gift1, gift2}&quot;, file = f) red_envelope1 = pow(Happy_2024 * m + Exuberant_p.order(), Haqqy_2024, Hanny_2024) red_envelope2 = pow(Haqqy_2024 * m + Exuberant_q.order(), Happy_2024, Hanny_2024) print(f&quot;OKOK ~ I'll give U both my red envelopes: {(red_envelope1 + red_envelope2) % Hanny_2024}&quot;, file = f) output.txt I'll give the gifts to U: (20243063012381093065881715376803640816923818203625911640694784993789286636611180835921608390045413835542916314861539938722171842014382670606414163394994894668365164929867556130798284960121925034107155666591563718174618437343159515015854655008175217672889911863891053034708651435516540210570245991063171289, 3082830559038877744539857448969808147340468463825357858541058129026110543191536241000397185264316057842094866363953733054989122356139453391356731191975829726832037786724893103057593038097144042673463810432983923372914638559633536471618619482302004617729891895118724873404754109722821248796445568519005866543646123446178955716385193501431092935028347031054773643129268914254426313530748324498727786408429432156630438289014574042635727761302151785956285737839574363413926555001728577343808599432210101775474025849266347224644582573221902585346919924996022499981173366240328668308502429507808470604746535923016683822196192993568289713072203814997890729262294909812821367061856088587537284075245689333865060423210347243013777511472403383304, 3082830559038877744539857448969808147340468463825357858541058129026110543191536241000397185264316057842094866363953733054989122356139453391356731191975829726832037786724893103057593038216217536027471947135543545371933118755272502325512823354293788008534797452079854008261955881875509964629925233416040952762759456529527642367686423321679563388067512673864367064259939501631392224619750617648481056541218717491489589148264984800793218746131598354744063462469714933567095917446196156778081743234319680672351161560960057307138485005738193883799762282567263840999618884631103691058355449154243356632772447934686630333029322247571260185386757991734700408212263554584499979733547418238195693215881963434496586637612459533424028727466150670988) OKOK ~ I'll give U both my red envelopes: 2053306399329493484171909216754446971778876338572305861281393386450367892503612914088507585084261917515228499040036138151202134583664706045917520505194094450066544241663702222706889993979023385508314787933724825993887808366549319278298208023774104687051338473854159671013079568527042769852891874689463806 解题思路与解题代码 Point 1：椭圆曲线基本常识 关注到代码片段： Happy_2024, Haqqy_2024 = getPrime(New_Year // 4), getPrime(New_Year // 4) while (Happy_2024 % 3 == Haqqy_2024 % 3): Happy_2024 = getPrime(New_Year // 4) p, q = choice(Goldbach_christian) Exuberant_p = EllipticCurve(GF(Happy_2024), [0, p]) Exuberant_q = EllipticCurve(GF(Haqqy_2024), [0, q]) 此处素数模 333 是一个十分重要的提示，根据有限域上椭圆曲线点群的相关结论，如果素数 p≡2(mod3)p \\equiv 2 \\pmod{3}p≡2(mod3) ，那么 Fp\\mathbb{F}_pFp​ 上形如 y2=x3+cy^2 = x^3 + cy2=x3+c 的椭圆曲线的阶一定满足 ∣E(Fp)∣=p+1\\lvert E(\\mathbb{F}_p)\\rvert = p + 1∣E(Fp​)∣=p+1 。因此上述代码一定满足下列条件： assert (Exuberant_p.order() == Happy_2024 + 1 and Exuberant_q.order() != Haqqy_2024 + 1) or (Exuberant_p.order() != Happy_2024 + 1 and Exuberant_q.order() == Haqqy_2024 + 1) 证明 p≡2(mod3)p \\equiv 2 \\pmod{3}p≡2(mod3) 的情况： 根据熟知的有限域上椭圆曲线点的计算公式（公式依据就是遍历每个 xxx ，计算 yyy 可以开平方的数量）： #E(Fp)=1+∑k∈Fp((k3+cp)+1)=p+1+∑k∈Fp(k3+cp)=p+1+∑k∈Fp(kp)=p+1\\begin{aligned} \\#E(\\mathbb{F}_p) &amp;= 1 + \\sum\\limits_{k\\in\\mathbb{F}_p} \\left(\\left(\\dfrac{k^3+c}{p}\\right) + 1\\right) \\\\ &amp;= p + 1 + \\sum\\limits_{k\\in\\mathbb{F}_p} \\left(\\dfrac{k^3+c}{p}\\right) \\\\ &amp;= p + 1 + \\sum\\limits_{k\\in\\mathbb{F}_p} \\left(\\dfrac{k}{p}\\right) \\\\ &amp;= p + 1 \\end{aligned} #E(Fp​)​=1+k∈Fp​∑​((pk3+c​)+1)=p+1+k∈Fp​∑​(pk3+c​)=p+1+k∈Fp​∑​(pk​)=p+1​ 注： 考虑 p≡2(mod3)p \\equiv 2\\pmod{3}p≡2(mod3)，不考虑 k=0k = 0k=0 ，由于 k13+c=k23+ck_1 ^ 3 + c = k_2 ^ 3 + ck13​+c=k23​+c ⇔\\Leftrightarrow⇔ k13=k23k_1 ^ 3 = k_2 ^ 3k13​=k23​ ，而 p−1≡1(mod3)p - 1 \\equiv 1\\pmod{3}p−1≡1(mod3) ，根据费马小定理 k1p−1=k2p−1=1k_1 ^ {p-1} = k_2^{p-1} = 1k1p−1​=k2p−1​=1 ，那么 k13+c=k23+ck_1 ^ 3 + c = k_2 ^ 3 + ck13​+c=k23​+c ⇔\\Leftrightarrow⇔ k13⋅p−23=k23⋅p−23k_1^{3\\cdot \\frac{p-2}{3}} = k_2^{3\\cdot \\frac{p-2}{3}}k13⋅3p−2​​=k23⋅3p−2​​ ⇔\\Leftrightarrow⇔ k1=k2k_1 = k_2k1​=k2​ 。因此 k3+ck^3+ck3+c 恰好构成 ppp 的一个完全剩余系。（听起来高级一点的说法就是 x↦x3+cx \\mapsto x^3 + cx↦x3+c 为 Fp∗\\mathbb{F}_p^{*}Fp∗​ 上的一个内自同构） 二次剩余和二次非剩余的数量相等；000 的勒让德符号值为 000。 Point 2：广度优先搜索+爆破 记 pHp_HpH​ 和 qHq_HqH​ 分别表示 Happy_2024 和 Haqqy_2024 ，nHn_HnH​ 表示 Hanny_2024 ，另外记 aaa 和 bbb 分别表示 p 和 q pH,qHp_H, q_HpH​,qH​ 在十进制下可以被写成如下形式： pH=a0+a110+a2102+⋯qH=b0+b110+b2102+⋯\\begin{aligned} p_H &amp;= a_0 + a_1 10 + a_2 10^2 + \\cdots \\\\ q_H &amp;= b_0 + b_1 10 + b_2 10^2 + \\cdots \\end{aligned} pH​qH​​=a0​+a1​10+a2​102+⋯=b0​+b1​10+b2​102+⋯​ 记 f = lambda x: bytes_to_long(str(x).encode()) 为 fff 因此 f(x)f(x)f(x) 就可以写成： f(x)=(48+x0)+(48+x1)256+(48+x2)2562+⋯f(x) = (48 + x_0) + (48 + x_1) 256 + (48 + x_2) 256^2 + \\cdots f(x)=(48+x0​)+(48+x1​)256+(48+x2​)2562+⋯ 根据上一条对于有限域上椭圆曲线点群阶的讨论，不妨设 Exuberant_p.order() == Happy_2024 + 1 ，记 ngn_gng​ 表示这里的 gift1 = f(Exuberant_p.order() + q) * f(Haqqy_2024 + p) ，那么就有： nH=pH⋅qH=(p0+p110+p2102+⋯ )⋅(q0+q110+q2102+⋯ )ng=f(pH+1+b)⋅f(qH+a)=f(pH′)⋅f(qH′)=((48+p0′)+(48+p1′)256+(48+p2′)2562+⋯ )⋅((48+q0′)+(48+q1′)256+(48+q2′)2562+⋯ )\\begin{aligned} n_H &amp;= p_H \\cdot q_H \\\\ &amp;= (p_0 + p_1 10 + p_2 10^2 + \\cdots)\\cdot(q_0 + q_1 10 + q_2 10^2 + \\cdots) \\\\ n_g &amp;= f(p_H + 1 + b)\\cdot f(q_H + a) \\\\ &amp;= f(p_H')\\cdot f(q_H') \\\\ &amp;= \\left((48 + p_0') + (48 + p'_1) 256 + (48 + p_2') 256^2 + \\cdots\\right)\\cdot\\left((48 + q_0') + (48 + q_1') 256 + (48 + q_2') 256^2 + \\cdots\\right) \\end{aligned} nH​ng​​=pH​⋅qH​=(p0​+p1​10+p2​102+⋯)⋅(q0​+q1​10+q2​102+⋯)=f(pH​+1+b)⋅f(qH​+a)=f(pH′​)⋅f(qH′​)=((48+p0′​)+(48+p1′​)256+(48+p2′​)2562+⋯)⋅((48+q0′​)+(48+q1′​)256+(48+q2′​)2562+⋯)​ 考虑 nH≡(∑j=0i−1pj10j)⋅(∑j=0i−1qj10j)(mod10i)n_H \\equiv \\left(\\sum\\limits_{j=0}^{i-1} p_j 10^j\\right) \\cdot \\left(\\sum\\limits_{j=0}^{i-1} q_j 10^j\\right) \\pmod{10^i}nH​≡(j=0∑i−1​pj​10j)⋅(j=0∑i−1​qj​10j)(mod10i) 以及 ng≡(∑j=0i−1(48+pj′)256j)⋅(∑j=0i−1(48+qj′)256j)(mod256i)n_g \\equiv \\left(\\sum\\limits_{j=0}^{i-1} (48+p_j') 256^j\\right) \\cdot \\left(\\sum\\limits_{j=0}^{i-1} (48+q_j') 256^j\\right) \\pmod{256^i}ng​≡(j=0∑i−1​(48+pj′​)256j)⋅(j=0∑i−1​(48+qj′​)256j)(mod256i) 从低到高逐数位恢复即可。 这里可以使用递推或者递归实现，但是递归实现小心爆栈。 Point 3：小密钥空间 New_Year = 2024 Goldbach_christian = [(p, New_Year - p) for p in sieve_base if p &lt;= New_Year // 2 and isPrime(New_Year - p)] 根据上述代码可知，列表 Goldbach_christian 空间是很小的，因此枚举即可 至此已经可以求出两个素数了，下面先给出一部分代码。 from Crypto.Util.number import * New_Year = 2024 Goldbach_christian = [(p, New_Year - p) for p in sieve_base if p &lt;= New_Year // 2 and isPrime(New_Year - p)] def factor(nh, ng, a, b, f = lambda x: bytes_to_long(str(x).encode())): nh_p = None def test_digits(ps, qs): nonlocal nh_p if nh_p is not None: return False p = sum([pi * 10 ** i for i, pi in enumerate(ps)]) p_with_a = p + a new_ps = [int(i) for i in str(p_with_a).zfill(len(ps))[::-1]][:len(ps)] pp = sum([(48 + pi) &lt;&lt; (i * 8) for i, pi in enumerate(new_ps)]) q = sum([pi * 10 ** i for i, pi in enumerate(qs)]) q_with_b = q + b new_qs = [int(i) for i in str(q_with_b).zfill(len(qs))[::-1]][:len(qs)] qq = sum([(48 + qi) &lt;&lt; (i * 8) for i, qi in enumerate(new_qs)]) if p != 0 and p != 1 and nh % p == 0: nh_p = p return False m1 = 10 ** len(ps) m2 = 1 &lt;&lt; (len(qs) * 8) return (p * q) % m1 == nh % m1 and (pp * qq) % m2 == ng % m2 stack = [([], [])] while stack: ps, qs = stack.pop() stack += [(ps + [i], qs + [j]) for i in range(10) for j in range(10) if test_digits(ps + [i], qs + [j])] ng_p = f(nh_p + a) assert ng % ng_p == 0 return nh_p, nh // nh_p New_Year = 2024 Goldbach_christian = [(p, New_Year - p) for p in sieve_base if p &lt;= New_Year and isPrime(New_Year - p)] def get_factors(n, nn, ABlist): Hp, Hq, p, q = None, None, None, None for a, b in ABlist: try: Hp, Hq = factor(n, nn, a + 1, b) print(Hp, Hq, a, b) p, q = a, b break except: pass return Hp, Hq, p, q pH, qH, p, q = get_factors(n, g1, Goldbach_christian) if pH is None or qH is None: pH, qH, p, q = get_factors(n, g2, Goldbach_christian) Point 4：数论变换 这一部分是一个简单的数论变换。记 pHp_HpH​ 和 qHq_HqH​ 分别表示 Happy_2024 和 Haqqy_2024 ，nHn_HnH​ 表示 Hanny_2024 ，另外记 ωp\\omega_pωp​ 和 ωq\\omega_qωq​ 分别表示 Exuberant_p 和 Exuberant_q ，这些变量现在都已经是已知的了 那么根据代码片段： red_envelope1 = pow(Happy_2024 * m + Exuberant_p.order(), Haqqy_2024, Hanny_2024) red_envelope2 = pow(Haqqy_2024 * m + Exuberant_q.order(), Happy_2024, Hanny_2024) print(f&quot;OKOK ~ I'll give U both my red_envelopes: {(red_envelope1 + red_envelope2) % Hanny_2024}&quot;, file = f) 可以整理得到如下表达式： c≡(pH⋅m+ωp)qH+(qH⋅m+ωq)pH(modnH)c \\equiv (p_H \\cdot m + \\omega_p)^{q_H} + (q_H \\cdot m + \\omega_q)^{p_H} \\pmod{n_H} c≡(pH​⋅m+ωp​)qH​+(qH​⋅m+ωq​)pH​(modnH​) 注意到 nH=pH⋅qHn_H = p_H \\cdot q_HnH​=pH​⋅qH​ ，那么根据费马小定理可以得到如下方程组： {c≡ωpqH+qH⋅m+ωq(modpH)c≡pH⋅m+ωp+ωqpH(modqH)\\begin{cases} c \\equiv \\omega_p^{q_H} + q_H \\cdot m + \\omega_q &amp; \\pmod{p_H} \\\\ c \\equiv p_H \\cdot m + \\omega_p + \\omega_q^{p_H} &amp; \\pmod{q_H} \\\\ \\end{cases} {c≡ωpqH​​+qH​⋅m+ωq​c≡pH​⋅m+ωp​+ωqpH​​​(modpH​)(modqH​)​ 从而有： {mp≡qH−1⋅(c−ωpqH−ωq)(modpH)mq≡pH−1⋅(c−ωp−ωqpH)(modqH)\\begin{cases} m_p \\equiv q_H ^ {-1} \\cdot(c - \\omega_p^{q_H} - \\omega_q) &amp; \\pmod{p_H} \\\\ m_q \\equiv p_H ^ {-1} \\cdot(c - \\omega_p - \\omega_q^{p_H}) &amp; \\pmod{q_H} \\\\ \\end{cases} {mp​≡qH−1​⋅(c−ωpqH​​−ωq​)mq​≡pH−1​⋅(c−ωp​−ωqpH​​)​(modpH​)(modqH​)​ 最后利用中国剩余定理即可恢复 mmm 。 这里主要注意一点是前面解出来的小 p 和小 q 可能顺序不对应，调整一下就好了： # sagemath Ep = EllipticCurve(GF(pH), [0, p]) Eq = EllipticCurve(GF(qH), [0, q]) omega_p = Ep.order() omega_q = Eq.order() mp = inverse(int(qH), int(pH)) * (int(c) - int(pow(omega_p, qH, pH)) - int(omega_q)) % pH mq = inverse(int(pH), int(qH)) * (int(c) - int(pow(omega_q, pH, qH)) - int(omega_p)) % qH m = crt([mq, mp], [pH, qH]) print(long_to_bytes(int(m))) Ep = EllipticCurve(GF(pH), [0, q]) Eq = EllipticCurve(GF(qH), [0, p]) omega_p = Ep.order() omega_q = Eq.order() mp = inverse(int(qH), int(pH)) * (int(c) - int(pow(omega_p, qH, pH)) - int(omega_q)) % pH mq = inverse(int(pH), int(qH)) * (int(c) - int(pow(omega_q, pH, qH)) - int(omega_p)) % qH m = crt([mp, mq], [pH, qH]) print(long_to_bytes(int(m))) 完整解题代码 # sagemath n, g1, g2 = c = from Crypto.Util.number import * New_Year = 2024 Goldbach_christian = [(p, New_Year - p) for p in sieve_base if p &lt;= New_Year // 2 and isPrime(New_Year - p)] def factor(nh, ng, a, b, f = lambda x: bytes_to_long(str(x).encode())): nh_p = None def test_digits(ps, qs): nonlocal nh_p if nh_p is not None: return False p = sum([pi * 10 ** i for i, pi in enumerate(ps)]) p_with_a = p + a new_ps = [int(i) for i in str(p_with_a).zfill(len(ps))[::-1]][:len(ps)] pp = sum([(48 + pi) &lt;&lt; (i * 8) for i, pi in enumerate(new_ps)]) q = sum([pi * 10 ** i for i, pi in enumerate(qs)]) q_with_b = q + b new_qs = [int(i) for i in str(q_with_b).zfill(len(qs))[::-1]][:len(qs)] qq = sum([(48 + qi) &lt;&lt; (i * 8) for i, qi in enumerate(new_qs)]) if p != 0 and p != 1 and nh % p == 0: nh_p = p return False m1 = 10 ** len(ps) m2 = 1 &lt;&lt; (len(qs) * 8) return (p * q) % m1 == nh % m1 and (pp * qq) % m2 == ng % m2 stack = [([], [])] while stack: ps, qs = stack.pop() stack += [(ps + [i], qs + [j]) for i in range(10) for j in range(10) if test_digits(ps + [i], qs + [j])] ng_p = f(nh_p + a) assert ng % ng_p == 0 return nh_p, nh // nh_p New_Year = 2024 Goldbach_christian = [(p, New_Year - p) for p in sieve_base if p &lt;= New_Year and isPrime(New_Year - p)] def get_factors(n, nn, ABlist): Hp, Hq, p, q = None, None, None, None for a, b in ABlist: try: Hp, Hq = factor(n, nn, a + 1, b) print(Hp, Hq, a, b) p, q = a, b break except: pass return Hp, Hq, p, q pH, qH, p, q = get_factors(n, g1, Goldbach_christian) if pH is None or qH is None: pH, qH, p, q = get_factors(n, g2, Goldbach_christian) Ep = EllipticCurve(GF(pH), [0, p]) Eq = EllipticCurve(GF(qH), [0, q]) omega_p = Ep.order() omega_q = Eq.order() mp = inverse(int(qH), int(pH)) * (int(c) - int(pow(omega_p, qH, pH)) - int(omega_q)) % pH mq = inverse(int(pH), int(qH)) * (int(c) - int(pow(omega_q, pH, qH)) - int(omega_p)) % qH m = crt([mq, mp], [pH, qH]) print(long_to_bytes(int(m))) Ep = EllipticCurve(GF(pH), [0, q]) Eq = EllipticCurve(GF(qH), [0, p]) omega_p = Ep.order() omega_q = Eq.order() mp = inverse(int(qH), int(pH)) * (int(c) - int(pow(omega_p, qH, pH)) - int(omega_q)) % pH mq = inverse(int(pH), int(qH)) * (int(c) - int(pow(omega_q, pH, qH)) - int(omega_p)) % qH m = crt([mp, mq], [pH, qH]) print(long_to_bytes(int(m))) Latte 题干代码 一杯地道的拿铁咖啡，配制的比例是牛奶占70%、奶沫20%、咖啡10%。不过我也有我自己的拿铁咖啡秘密配方，你能解开它吗？ Latte.py import os from Flag import FLAG from MyLatteRepo import CUP, SPOON from Crypto.Util.number import bytes_to_long, getRandomNBitInteger as RandBitInt Amount = 96 Milk = os.urandom(16) * 8 Espresso = FLAG + os.urandom(Amount - len(FLAG)) with open(r&quot;output.txt&quot;, &quot;w&quot;) as f: print(f&quot;Secret Recipe = {[tuple(RandBitInt(Amount) * TableWare + RandBitInt(Amount) for _ in range(2)) for TableWare in (CUP, SPOON)]}&quot;, file=f) print(f&quot;Thick Latte = {pow(SPOON, bytes_to_long(Espresso + Milk), CUP ** 2)}&quot;, file=f) MyLatteRepo.py from Crypto.Util.number import getPrime CUP, SPOON = getPrime(1024), getPrime(1023) output.txt Secret Recipe = [(7713728406427216751554669259392564225336715833405752115381741192770705127449580203149702790344362306038809396807649838869061646825414855115281945957936663046654597534205905897175890178111315995254386657057762733095874608001275952979326053898143312737463706959131172849869413280104618789870525444846308811177858689495229895344683454580950, 10768179705714029637486823876049385323286739410640293933059996834750818396728290193643930846035066620748980549564939970460538905794696240546865167074683494614932952147502138271504281179082644890287956486068437561613270593639955518366259238860093126375044566302145336839299698696953932193554693269889774553104747679934421788071379684047915), (2898813132870923822777364992441270262502451755815932783777103680715031737093464555201012481453587077640406026905664044181285477747422049637936736855670910340762277892609290987252636816482044722119626550674047412622124045604541059525595043435592277961925044167418669671070332108592596709889174367812547474906749734439633509985838606222960, 2367559009552417131041378739974356297751002698778465850165050259445912894845076511101152884465249070441230089677370105742148697551267296224211034179040069757613002687259581727661569679606228550112626907697624938047107562660618012512691699375628474791262692117911743763161978380251049593695853607487996373529877746744715681916370876905026)] Thick Latte = 20253232364768706926657485015049869073760656433294604067483464164523871937032855264502276827180968267948099001484311159380007672576388212344106685365998360069778982260692360184986401704121446642207721387626751348876990232847057047018213774615443495418352798433539096655873616282540001939164316406665677968957728127542212939916975714081533666005788317489175126976192690644215563210089888539431393271742697820031432708144235650686331750559997766949714325602181599668062799960432143171917892374753391669283145013751645161429336541215774184990625832380011450653150508569090082960763279097984362744541280481182272786223879 解题思路与解题代码 Point 1：AGCD问题 首先对于 Secret Recipe： print(f&quot;Secret Recipe = {[tuple(RandBitInt(Amount) * TableWare + RandBitInt(Amount) for _ in range(2)) for TableWare in (CUP, SPOON)]}&quot;, file=f) 设 CUP 为 uuu，SPOON 为 sss，那么给到的信息就是： {a1u+b1=h1a2u+b2=h2\\begin{cases} a_1 u + b_1 = h_1\\\\ a_2 u + b_2 = h_2\\\\ \\end{cases} {a1​u+b1​=h1​a2​u+b2​=h2​​ 以及 {a1′s+b1′=h1′a2′s+b2′=h2′\\begin{cases} a_1' s + b_1' = h_1'\\\\ a_2' s + b_2' = h_2'\\\\ \\end{cases} {a1′​s+b1′​=h1′​a2′​s+b2′​=h2′​​ 其中 aia_iai​ 、 bib_ibi​ 、ai′a_i'ai′​ 和 bi′b_i'bi′​ 为小的随机数，hih_ihi​ 和 hi′h_i'hi′​ 是已知的。 这是典型的 AGCD 问题，比如我们考虑针对 uuu 的这组等式 注意到 a2h1−a1h2=a2b1−b2a1a_2 h_1 - a_1 h_2 = a_2 b_1 - b_2 a_1 a2​h1​−a1​h2​=a2​b1​−b2​a1​ 等式右边是一个小数据 那么可以构造如下格子： (a2−a1)⋅(h110h201)=(a2b1−b2a1a2−a1)\\begin{pmatrix} a_2 &amp;-a_1 \\end{pmatrix} \\cdot \\begin{pmatrix} h_1 &amp; 1 &amp; 0 \\\\ h_2 &amp; 0 &amp; 1 \\end{pmatrix} = \\begin{pmatrix} a_2 b_1 - b_2 a_1 &amp; a_2 &amp; -a_1 \\end{pmatrix} (a2​​−a1​​)⋅(h1​h2​​10​01​)=(a2​b1​−b2​a1​​a2​​−a1​​) 右边是一个短向量，所以对左边的格子 (h110h201)\\begin{pmatrix}h_1 &amp; 1 &amp; 0 \\\\ h_2 &amp; 0 &amp; 1\\end{pmatrix}(h1​h2​​10​01​) 作 LLL 格基约化即可。 这一层的解题代码如下： with open(&quot;./output.txt&quot;, &quot;r&quot;) as f: s1, s2 = f.readlines() sp, sg = eval(s1.split(&quot;= &quot;)[1]) secret = int(s2.split(&quot;= &quot;)[1]) def getSec(h1, h2, bits): mat = matrix(ZZ, [[h1, 1, 0], [h2, 0, 1]]) mat = mat.LLL() t, a2, a1 = mat[0] a2, a1 = abs(a2), abs(a1) pre_p = h1 // a1 for i in range(pre_p &gt;&gt; bits, pre_p &gt;&gt; (bits - 1)): q = pre_p // (i + 1) for bias in range(-4, 5): r = q + bias if is_prime(r) and r.bit_length() == bits: return r print(&quot;Failed&quot;) p, g = getSec(*sp, 1024), getSec(*sg, 1023) print(p) print(g) Point 2： p2p^2p2 下的离散对数转化为背包问题 由于 Milk = os.urandom(16) * 8 所以可以设 设随机产生的部分为 xxx， A = bytes_to_long((b&quot;\\x00&quot;*15 + b&quot;\\x01&quot;) * 8) 则 assert bytes_to_long(Milk) == x * A 简记为数学公式： Milk=A⋅x\\text{Milk} = A\\cdot xMilk=A⋅x 其中 x∼2128x \\sim 2^{128}x∼2128 进一步观察第二个式子，根据 len(Milk) == 128 ，同时设 y = bytes_to_long(FLAG)，那么有数学关系： s=Thick Latte=g2128×8y+x⋅A(modp2)s = \\text{Thick Latte} = g^{2^{128\\times 8}y + x\\cdot A}\\pmod{p^2}s=Thick Latte=g2128×8y+x⋅A(modp2) 记 B=2128×8B = 2^{128\\times 8}B=2128×8 则化为： s=gAx+By(modp2)=(gA)x⋅(gB)y(modp2)\\begin{aligned} s &amp; = g^{Ax+By}\\pmod{p^2} \\\\ &amp; = \\left(g^A\\right)^x \\cdot \\left(g^B\\right)^y\\pmod{p^2} \\end{aligned} s​=gAx+By(modp2)=(gA)x⋅(gB)y(modp2)​ 其中 x∼2128x\\sim 2^{128}x∼2128 ， y∼2768y\\sim 2^{768}y∼2768 ， p∼21024p \\sim 2^{1024}p∼21024 考虑如下推导： s′=sp−1=(gA(p−1))x⋅(gB(p−1))y(modp2)s' = s^{p-1} = \\left(g^{A(p-1)}\\right)^x\\cdot \\left(g^{B(p-1)}\\right)^y\\pmod{p^2} s′=sp−1=(gA(p−1))x⋅(gB(p−1))y(modp2) 注意，根据费马小定理，gA(p−1)≡1(modp)g^{A(p-1)}\\equiv 1\\pmod{p}gA(p−1)≡1(modp) ，以及 gB(p−1)≡1(modp)g^{B(p-1)}\\equiv 1\\pmod{p}gB(p−1)≡1(modp) ，则说明 gA(p−1)−1g^{A(p-1)} - 1gA(p−1)−1 和 gB(p−1)−1g^{B(p-1)} - 1gB(p−1)−1 均为 ppp 的倍数。 设 gA(p−1)−1=apg^{A(p-1)} - 1 = apgA(p−1)−1=ap ， gB(p−1)−1=bpg^{B(p-1)} - 1 = bpgB(p−1)−1=bp ，则根据二项式定理有： s′=(ap+1)x⋅(bp+1)y(modp2)=(xap+1)⋅(ybp+1)(modp2)=(ax+by)⋅p+1(modp2)\\begin{aligned} s' &amp; = (ap+1)^x\\cdot (bp+1)^y &amp;\\pmod{p^2} \\\\ &amp; = (xap+1)\\cdot (ybp+1) &amp;\\pmod{p^2} \\\\ &amp; = (ax+by)\\cdot p + 1 &amp;\\pmod{p^2} \\end{aligned} s′​=(ap+1)x⋅(bp+1)y=(xap+1)⋅(ybp+1)=(ax+by)⋅p+1​(modp2)(modp2)(modp2)​ 即： S′=s′−1p=ax+by(modp)S' = \\dfrac{s' - 1}{p} = ax + by \\pmod{p} S′=ps′−1​=ax+by(modp) 其中 x∼2128x\\sim 2^{128}x∼2128 ， y∼2768y\\sim 2^{768}y∼2768 ， p∼21024p \\sim 2^{1024}p∼21024 进一步转化为： −x=−a−1S′+a−1b⋅y(modp)-x = - a^{-1}S' + a^{-1}b\\cdot y\\pmod{p} −x=−a−1S′+a−1b⋅y(modp) 设 S=a−1S′ mod pS = a^{-1}S'\\bmod{p}S=a−1S′modp ， 以及 C=a−1b mod pC = a^{-1}b\\bmod{p}C=a−1bmodp 得到 −x=−S+Cy−kp-x = - S + Cy - kp−x=−S+Cy−kp 很小，其中 x∼2128x\\sim 2^{128}x∼2128 ， k∼y∼2768k\\sim y\\sim 2^{768}k∼y∼2768 ， S∼C∼p∼21024S \\sim C \\sim p \\sim 2^{1024}S∼C∼p∼21024 因此可以构造一个矩阵 M=(12768−1280C02128S00p)M = \\begin{pmatrix} \\dfrac{1}{2^{768 - 128}} &amp; 0 &amp; C \\\\ 0 &amp; 2^{128} &amp; S \\\\ 0 &amp; 0 &amp; p \\end{pmatrix} M=⎝⎜⎜⎛​2768−1281​00​021280​CSp​⎠⎟⎟⎞​ 满足： (y−1k)⋅M=(y2640−2128−x)\\begin{pmatrix} y &amp; -1 &amp; k\\end{pmatrix} \\cdot M = \\begin{pmatrix} \\dfrac{y}{2^{640}} \\\\\\\\ -2^{128} \\\\\\\\ -x \\end{pmatrix} (y​−1​k​)⋅M=⎝⎜⎜⎜⎜⎜⎜⎛​2640y​−2128−x​⎠⎟⎟⎟⎟⎟⎟⎞​ 其中 12640\\dfrac{1}{2^{640}}26401​ 和 21282^{128}2128 是为了控制最后向量的大小，和矩阵左乘系数恰好是我们想要的，考察选手对于利用格规约解决小未知数方程的手段，对于格子构造的理解。 unit = b&quot;\\x00&quot; * 15 + b&quot;\\x01&quot; A = bytes_to_long(unit * 8) unit = b&quot;\\x00&quot; * 16 B = bytes_to_long(b&quot;\\01&quot; + unit * 8) ap = pow(g, A * (p - 1), p ** 2) - 1 bp = pow(g, B * (p - 1), p ** 2) - 1 assert int(ap) % p == 0 assert int(bp) % p == 0 a, b = int(ap) // p, int(bp) // p C = (b * inverse(a, p)) % p S = int(pow(int(secret), p - 1, p ** 2)) - 1 assert int(S) % p == 0 S = ((int(S) // p) * inverse(a, p)) % p M = matrix([[1/2**(768 - 128), 0, C], [0, 2**128, S], [0, 0, p]]) ML = M.LLL() print(ML) for v in ML: the_flag = abs((v * (2 ** (768 - 128)))[0]) print(long_to_bytes(int(the_flag))) 完整解题代码 from Crypto.Util.number import * with open(&quot;./output.txt&quot;, &quot;r&quot;) as f: s1, s2 = f.readlines() sp, sg = eval(s1.split(&quot;= &quot;)[1]) secret = int(s2.split(&quot;= &quot;)[1]) def getSec(h1, h2, bits): mat = matrix(ZZ, [[h1, 1, 0], [h2, 0, 1]]) mat = mat.LLL() t, a2, a1 = mat[0] a2, a1 = abs(a2), abs(a1) pre_p = h1 // a1 for i in range(pre_p &gt;&gt; bits, pre_p &gt;&gt; (bits - 1)): q = pre_p // (i + 1) for bias in range(-4, 5): r = q + bias if is_prime(r) and r.bit_length() == bits: return r print(&quot;Failed&quot;) p, g = getSec(*sp, 1024), getSec(*sg, 1023) print(p) print(g) unit = b&quot;\\x00&quot; * 15 + b&quot;\\x01&quot; A = bytes_to_long(unit * 8) unit = b&quot;\\x00&quot; * 16 B = bytes_to_long(b&quot;\\01&quot; + unit * 8) ap = pow(g, A * (p - 1), p ** 2) - 1 bp = pow(g, B * (p - 1), p ** 2) - 1 assert int(ap) % p == 0 assert int(bp) % p == 0 a, b = int(ap) // p, int(bp) // p C = (b * inverse(a, p)) % p S = int(pow(int(secret), p - 1, p ** 2)) - 1 assert int(S) % p == 0 S = ((int(S) // p) * inverse(a, p)) % p M = matrix([[1/2**(768 - 128), 0, C], [0, 2**128, S], [0, 0, p]]) ML = M.LLL() print(ML) for v in ML: the_flag = abs((v * (2 ** (768 - 128)))[0]) print(long_to_bytes(int(the_flag)))","link":"2024/12/09/ForUCATFLAGS2024/"},{"title":"一个素数拆分成特定形式平方和的例子","text":"听说有人在催我写博客 1. x2+y2x^2+y^2x2+y2形式的素数 考虑这样一个十分经典的问题： 对于不定方程 x2+y2=px^2+y^2=px2+y2=p，其中 ppp 为正素数，那么该方程是否存在整数解？ OK，我们把问题简化一下： 对于不定方程 x2+y2≡0(modp)x^2+y^2\\equiv 0\\pmod{p}x2+y2≡0(modp)，其中 ppp 为正素数，那么该方程是否存在非平凡整数解？ 1.1 探索这样素数的必要条件（性质） 1.1.1 利用完全平方数的同余性质 先尝试几个小的素数，我们观察一下规律： 素数 存在的某组解 222 (1,1)(1,1)(1,1) 333 无解 555 (1,2)(1, 2)(1,2) 777 无解 111111 无解 131313 (2,3)(2, 3)(2,3) 171717 (1,4)(1, 4)(1,4) 191919 无解 相信这里大家已经发现一些规律了。让我们进一步进行探索。 对同余的性质比较熟悉的小伙伴会注意到，完全平方数在同余情况下会呈现一些规律，比如： 模数 可能的余数 333 000, 111 444 000, 111 555 000, 111, 444 ⋯\\cdots⋯ ⋯\\cdots⋯ 是的，我们可以看到，上述列出的小素数中，除了特殊的素数 222 ，只要 p≡3(mod4)p\\equiv 3\\pmod{4}p≡3(mod4) 我们就枚举不出解，而当然 p≡1(mod4)p\\equiv 1\\pmod{4}p≡1(mod4) 的时候，我们总是找到了一组解。 为了方便讨论，之后的 ppp 均考虑为正奇素数。 要想要排除掉 p≡3(mod4)p\\equiv 3\\pmod{4}p≡3(mod4) 这个情况其实是很容易的。只需要在方程 x2+y2=px^2 + y^2=px2+y2=p 两端同时模掉 444 ，根据前面的铺垫，可以知道 x2+y2(mod4)x^2 + y^2 \\pmod{4}x2+y2(mod4) 只会有三种取值，即 000, 111, 222，这说明对于正奇素数只可能有 p≡1(mod4)p\\equiv 1\\pmod{4}p≡1(mod4) 。 此时我们获得了正素数 p=x2+y2p=x^2+y^2p=x2+y2 有解的一个必要条件： p=2 或者 p≡1(mod4)p = 2 \\text{ 或者 } p \\equiv 1 \\pmod{4} p=2 或者 p≡1(mod4) 1.1.2 利用二次同余方程（二次剩余） 到这里有经验的伙伴就看出来，不妨设 y≠0y\\neq 0y​=0 ，把变量挪到一边那么就有： (xy−1)2=−1(modp)\\left(xy^{-1}\\right)^2=-1\\pmod{p} (xy−1)2=−1(modp) 设 z=xy−1z=xy^{-1}z=xy−1 ，那么方程就转化为： z2=−1(modp)z^2=-1\\pmod{p} z2=−1(modp) 问题即变成了，−1-1−1 是否能在 Zp\\mathbb{Z}_pZp​ 中开根号，或说 Zp\\mathbb{Z}_pZp​ 中是否有一个其平方为 −1-1−1 的元素？ 先停一停，让我们在这里插播一个同余理论中十分重要的定理： 费马小定理（Fermat’s little theorem） 对于一个素数 ppp ，如果 整数 aaa 与 ppp 互素 ，那么 ap−1≡1(modp)a^{p-1}\\equiv 1\\pmod{p}ap−1≡1(modp) 同样地也可以将特殊情况囊括进去，即对 任意整数 aaa 都有： ap≡a(modp)a^{p}\\equiv a \\pmod{p} ap≡a(modp) 如果我们把这个定理应用于 zzz ，那么就有： zp−1≡1(modp)z^{p-1}\\equiv 1\\pmod{p} zp−1≡1(modp) 同时我们先前已经假设 ppp 为奇素数，那么 p−1p-1p−1 实际上就是偶数，也就有： (z2)p−12=zp−1≡1(modp)(z^2)^{\\frac{p-1}{2}}=z^{p-1}\\equiv 1\\pmod{p} (z2)2p−1​=zp−1≡1(modp) 好的我们回到刚刚的问题，注意到两个条件 (z2)p−12=zp−1≡1(modp)(z^2)^{\\frac{p-1}{2}}=z^{p-1}\\equiv 1\\pmod{p}(z2)2p−1​=zp−1≡1(modp) 以及 z2=−1(modp)z^2=-1\\pmod{p}z2=−1(modp) ，结合起来就是： (−1)p−12≡1(modp)(-1)^{\\frac{p-1}{2}}\\equiv 1\\pmod{p} (−1)2p−1​≡1(modp) 这个等式并不总是成立，我们注意到，只有当 p−12\\frac{p-1}{2}2p−1​ 也是偶数的时候，才成立。殊途同归，我们了一个相同的必要条件： p≡1(mod4)p\\equiv 1\\pmod{4} p≡1(mod4) 走到这里其实我们其实可以更进一步，将上述 −1-1−1 考虑为更一般的整数 ttt （不为 ppp 的倍数），那么不难证明： ∃x∈Zp∗ s.t. x2≡t(modp) ⟺ tp−12≡1(modp)\\exists x\\in\\mathbb{Z}_p^{*}\\text{ s.t. } x^2\\equiv t\\pmod{p}\\iff t^{\\frac{p-1}{2}}\\equiv 1\\pmod{p}∃x∈Zp∗​ s.t. x2≡t(modp)⟺t2p−1​≡1(modp) ∄x∈Zp∗ s.t. x2≡t(modp) ⟺ tp−12≡−1(modp)\\not\\exists x\\in\\mathbb{Z}_p^{*}\\text{ s.t. } x^2\\equiv t\\pmod{p}\\iff t^{\\frac{p-1}{2}}\\equiv -1\\pmod{p}​∃x∈Zp∗​ s.t. x2≡t(modp)⟺t2p−1​≡−1(modp) （注意到由费马小定理， tp−1−1=(tp−12−1)(tp−12+1)≡0(modp)t^{p-1}-1 = \\left(t^{\\frac{p-1}{2}}-1\\right)\\left(t^{\\frac{p-1}{2}} + 1\\right)\\equiv 0\\pmod{p}tp−1−1=(t2p−1​−1)(t2p−1​+1)≡0(modp)，且 Zp\\mathbb{Z}_pZp​ 为整环） 这种判别 Zp∗\\mathbb{Z}_p^*Zp∗​ 上某个元素是否能开方的方法称为欧拉判据，而上述这样的元素开方问题称为二次剩余问题，如果在模素数 ppp 的情况下，对 t∈Zp∗t\\in\\mathbb{Z}_p^{*}t∈Zp∗​ 有 ∃x∈Zp∗ s.t. x2≡t(modp)\\exists x\\in\\mathbb{Z}_p^{*}\\text{ s.t. } x^2\\equiv t\\pmod{p}∃x∈Zp∗​ s.t. x2≡t(modp)，那么就称 ttt 为 素数 ppp 的二次剩余，否则称为二次非剩余。我们常常用勒让德符号（Legendre symbol） 来表示： 勒让德符号 (tp)={1t 是p 的二次剩余−1t 是p 的二次非剩余0t 是p 的倍数\\left( \\dfrac{t}{p} \\right) = \\begin{cases} 1 &amp; t \\text{ 是} p \\text{ 的二次剩余} \\\\ -1 &amp; t \\text{ 是} p \\text{ 的二次非剩余} \\\\ 0 &amp; t \\text{ 是} p \\text{ 的倍数} \\end{cases} (pt​)=⎩⎪⎪⎨⎪⎪⎧​1−10​t 是p 的二次剩余t 是p 的二次非剩余t 是p 的倍数​ 将上述我们所讨论的内容总结成定理，就是下面欧拉判别式： 欧拉判据 (tp)=tp−12(modp)\\left( \\dfrac{t}{p} \\right) = t^{\\frac{p-1}{2}}\\pmod{p} (pt​)=t2p−1​(modp) 当然，二次剩余的理论十分深刻，我们这里暂时就不做深刻讨论，此处不加证明地给出几个有关奇素数 ppp 勒让德符号的计算规律： （积性）若 p∤m⋅np \\not| m\\cdot np​∣m⋅n ，则有： (mp)(np)=(mnp)\\left( \\dfrac{m}{p} \\right) \\left( \\dfrac{n}{p} \\right) = \\left( \\dfrac{mn}{p} \\right)(pm​)(pn​)=(pmn​) （平移不变性） ∀k∈Z\\forall k\\in \\mathbb{Z}∀k∈Z ，总有 (kp+tp)=(tp)\\left( \\dfrac{kp+t}{p} \\right) = \\left( \\dfrac{t}{p} \\right)(pkp+t​)=(pt​) （单位元(unit)的勒让德符号） (1p)=1\\left( \\dfrac{1}{p} \\right) = 1(p1​)=1 ； (−1p)=(−1)p−12\\left( \\dfrac{-1}{p} \\right) = (-1)^{\\frac{p-1}{2}}(p−1​)=(−1)2p−1​ （偶素数的勒让德符号） (2p)=(−1)p2−18\\left( \\dfrac{2}{p} \\right) = (-1)^{\\frac{p^2-1}{8}}(p2​)=(−1)8p2−1​ （二次互反律）对两个不等的奇素数 p,qp, qp,q 有： (pq)(qp)=(−1)12(p−1)(q−1)\\left( \\dfrac{p}{q} \\right)\\left( \\dfrac{q}{p} \\right) = (-1) ^ {\\frac{1}{2}(p - 1)(q - 1)}(qp​)(pq​)=(−1)21​(p−1)(q−1) 计算应用： （利用整数标准分解计算勒让德符号） (tp)=(±1p)(2p)r(q1p)l1⋯(qsp)ls\\left( \\dfrac{t}{p} \\right) = \\left( \\dfrac{\\pm 1}{p} \\right)\\left( \\dfrac{2}{p} \\right) ^ r \\left( \\dfrac{q_ 1}{p} \\right) ^ {l_ 1} \\cdots \\left( \\dfrac{q_ s}{p} \\right) ^ {l_ s}(pt​)=(p±1​)(p2​)r(pq1​​)l1​⋯(pqs​​)ls​ 这时回到原问题 z2≡−1(modp)z^2\\equiv -1\\pmod{p}z2≡−1(modp) ，问题就很清楚了。 注：勒让德符号能一定意义上推广为雅可比符号，利用雅克比符号及其相关性质，我们可以类似于辗转相除法求得各种形如 x2≡a(modn)x^2\\equiv a\\pmod{n}x2≡a(modn) （其中这里不再要求 nnn 为奇素数）解的存在性问题。 1.1.3 构造的方法 对于这个问题，其实我们有一个构造型的结果，说明 p≡1(mod4)p\\equiv 1\\pmod{4}p≡1(mod4) 时 x2≡−1(modp)x^2\\equiv -1 \\pmod{p}x2≡−1(modp) 总是有解的。 这里还是会涉及到一个重要数论/代数定理： 威尔逊定理（Wilson’s theorem） 对于一个正整数 ppp ，有： p 为素数 ⟺ (p−1)!≡−1(modp)p \\text{ 为素数 } \\iff (p-1)!\\equiv -1\\pmod{p} p 为素数 ⟺(p−1)!≡−1(modp) 这个定理的含义可以如此理解：考虑域 Zp\\mathbb{Z}_pZp​ 上的方程 xp−1−1≡0(modp)x^{p-1} - 1 \\equiv 0\\pmod{p}xp−1−1≡0(modp) ，那么它的根就是 Zp\\mathbb{Z}_pZp​ 的所有非零元素，于是根据韦达定理有： ∏i=1p−1xi≡−1(modp) ⟺ ∏i=1p−1i≡−1(modp) ⟺ (p−1)!≡−1(modp)\\begin{aligned} \\prod_{i=1}^{p-1} x_i \\equiv -1\\pmod{p} &amp;\\iff \\prod_{i=1}^{p-1} i \\equiv -1\\pmod{p} \\\\ &amp;\\iff (p-1)!\\equiv -1\\pmod{p} \\end{aligned} i=1∏p−1​xi​≡−1(modp)​⟺i=1∏p−1​i≡−1(modp)⟺(p−1)!≡−1(modp)​ 到这里我又想多嘴一下，其实Wilson定理可以使用Sylow第三定理进行证明。 Sylow第三定理 设有限群 ∣G∣=pαm|G|=p^{\\alpha} m∣G∣=pαm ，其中 p∤mp\\not| mp​∣m ，那么 GGG 的 Sylow-p\\text{Sylow-}pSylow-p 子群（即 GGG 的 pαp^{\\alpha}pα 阶子群） 的个数 NpN_pNp​ 满足： Np=[G:NG(P)]N_p = \\left[ G:N_G(P) \\right]Np​=[G:NG​(P)] Np≡1(modp)N_p\\equiv 1\\pmod{p}Np​≡1(modp) Np∣mN_p\\mid mNp​∣m 其中 NG(P)={g∈G∣gPg−1=P}N_G(P)=\\left\\{ g\\in G\\mid gPg^{-1}=P \\right\\}NG​(P)={g∈G∣gPg−1=P} 为 PPP 在 GGG 中的正规化子。 对整数 ppp ，考虑置换群 SpS_pSp​ 的 Sylow-p\\text{Sylow-}pSylow-p 子群，注意到 ∣Sp∣=p!|S_p|=p!∣Sp​∣=p!。 若 ppp 为素数，那么 SpS_pSp​ 的 Sylow-p\\text{Sylow-}pSylow-p 子群的阶恰好为 ppp，从而 SpS_pSp​ 的 Sylow-p\\text{Sylow-}pSylow-p 子群恰为各个不同 ppp-循环生成的循环子群，这样的子群全体记为 Sylp(Sp)\\text{Syl}_p(S_p)Sylp​(Sp​)，容易知道 SpS_pSp​ 的 Sylow-p\\text{Sylow-}pSylow-p 子群个数 Np=∣Sylp(Sp)∣=p!p⋅(p−1)=(p−2)!N_p = |\\text{Syl}_p(S_p)|=\\dfrac{p!}{p \\cdot (p-1)} = (p-2)!Np​=∣Sylp​(Sp​)∣=p⋅(p−1)p!​=(p−2)! （除以的 ppp 是注意到 (i1 i2 ⋯ ip)(i_1\\ i_2\\ \\cdots\\ i_p)(i1​ i2​ ⋯ ip​) 与 (i2 i3 ⋯ ip i1)(i_2\\ i_3\\ \\cdots\\ i_p\\ i_1)(i2​ i3​ ⋯ ip​ i1​)是等价的；除以的 (p−1)(p-1)(p−1) 是因为循环群的阶数是 (p−1)(p-1)(p−1)）。 从而根据 Sylow第三定理： (p−2)!≡1(modp)(p-2)!\\equiv 1\\pmod p (p−2)!≡1(modp) 即 (p−1)!≡p−1≡−1(modp)(p-1)!\\equiv p-1\\equiv -1\\pmod{p} (p−1)!≡p−1≡−1(modp) 若 ppp 不是素数，那么 ∣Sylp(Sp)∣≠(p−2)!|\\text{Syl}_p(S_p)|\\neq (p-2)!∣Sylp​(Sp​)∣​=(p−2)!，具体请读着自行计算。 现在回到我们的问题上，考虑 p=4k+1p=4k+1p=4k+1 的情形。 注意到由Wilson定理： (4k)!≡−1(modp)(4k)!\\equiv -1\\pmod{p} (4k)!≡−1(modp) 即： (4k)!≡−1(mod4k+1) ⟺ (4k)⋯(2k+1)⋅(2k)!≡−1(mod4k+1) ⟺ (−1)⋯(−2k)⋅(2k)!≡−1(mod4k+1) ⟺ (−1)2k⋅((2k)!)2≡−1(mod4k+1) ⟺ ((2k)!)2≡−1(mod4k+1)\\begin{aligned} &amp;(4k)!\\equiv -1\\pmod{4k+1}\\\\ \\iff &amp;(4k)\\cdots(2k+1) \\cdot (2k)! \\equiv -1\\pmod{4k+1}\\\\ \\iff &amp;(-1)\\cdots(-2k) \\cdot (2k)! \\equiv -1\\pmod{4k+1}\\\\ \\iff &amp;(-1)^{2k} \\cdot \\left((2k)!\\right)^2 \\equiv -1\\pmod{4k+1}\\\\ \\iff &amp;\\left((2k)!\\right)^2 \\equiv -1\\pmod{4k+1} \\end{aligned} ⟺⟺⟺⟺​(4k)!≡−1(mod4k+1)(4k)⋯(2k+1)⋅(2k)!≡−1(mod4k+1)(−1)⋯(−2k)⋅(2k)!≡−1(mod4k+1)(−1)2k⋅((2k)!)2≡−1(mod4k+1)((2k)!)2≡−1(mod4k+1)​ 即取 x=2k!x=2k!x=2k! ，即可。 1.2 必要条件是否充分？ 我们花了很多时间来讨论 $ x^2 + y^2 \\equiv 0\\ p $ 的解的情况 1.2.1 数论的方法 1.2.2 几何（格）的方法 1.3. 一个例子：x2+xy+y2x^2 + xy + y^2x2+xy+y2 形式的素数","link":"2024/10/08/p=x2+ny2/"},{"title":"Rust 安装过程中遇到的一些小问题","text":"不必先安装 Visual Studio，可以直接安装 Rust。建议先安装 MinGW64（ucrt），然后选择 rustup-init 的选项 2 自行配置。点击跳转参考1，点击跳转参考2 建议检查一下 gcc 版本，别太低了。。。（与安全选项有关） 调整安装路径。方法：自行配置环境变量 RUSTUP_HOME 和 CARGO_HOME 点击跳转参考 出现报错 error: linker `link.exe` not found，方法（点击跳转参考） 依次执行以下命令即可 rustup toolchain install stable-x86_64-pc-windows-gnu rustup default stable-x86_64-pc-windows-gnu","link":"2024/12/20/rust-0/"},{"title":"手搓的简易基于 rust 的自己设计数学语言的解释器，很爽！","text":"关于人在不想干正事的时候能干出啥来。。。 第一次记录：2024年12月24日丑时 有不少 Bug，稳定性可能不是很好，但是很爽！（比如优先级问题） 项目结构如下！ MrMath ├─ ... ├─ Cargo.lock ├─ Cargo.toml └─ src ├─ backend │ ├─ ast.rs │ ├─ bigint │ │ ├─ fraction.rs │ │ ├─ matrix.rs │ │ └─ mod.rs │ ├─ driver.rs │ ├─ interpreter │ │ └─ mod.rs │ ├─ mod.rs │ └─ parser │ ├─ mod.rs │ └─ token.pest ├─ basic ├─ frontend │ ├─ help.rs │ ├─ history.rs │ ├─ mod.rs │ └─ service.rs ├─ hello.rs └─ main.rs 其中 token.pest 文件如下： WHITE_SPACE = _{ &quot; &quot; | &quot;\\t&quot; | &quot;\\r&quot; } GRAMMAR = { SOI ~ TRANS_UNIT ~ EOI } NEWLINE = _{ &quot;\\n&quot; } TRANS_UNIT = { BLOCK } // BLOCK = { (STMT ~ NEWLINE) + } BLOCK = { STMT* } STMT = { VAR_STMT | EXPR_STMT | PRINT_STMT } VAR_STMT = { VAR ~ WHITE_SPACE* ~ ID ~ WHITE_SPACE* ~ &quot;=&quot; ~ WHITE_SPACE* ~ TYPE ~ WHITE_SPACE* ~ EXPR ~ WHITE_SPACE* ~ &quot;;&quot; } // EXPR_STMT = { EXPR ~ WHITE_SPACE* ~ &quot;;&quot; } EXPR_STMT = { EXPR ~ WHITE_SPACE* } PRINT_STMT = { &quot;print&quot; ~ WHITE_SPACE* ~ EXPR ~ WHITE_SPACE* ~ &quot;;&quot; } ID = { ASCII_ALPHA ~ ASCII_ALPHA_NUM* } ASCII_ALPHA_NUM = { ASCII_ALPHA | ASCII_DIGIT } EXPR = { ATOM_EXPR ~ (INFIX_OPS ~ ATOM_EXPR)* } PREFIX_OPS = { (WHITE_SPACE* ~ PREFIX_OP)* ~ WHITE_SPACE* } POSTFIX_OPS = { (WHITE_SPACE* ~ POSTFIX_OP)* } INFIX_OPS = { WHITE_SPACE* ~ INFIX_OP ~ WHITE_SPACE*} ATOM_EXPR = { PREFIX_OPS ~ PRIMARY_EXPR ~ POSTFIX_OPS } PRIMARY_EXPR = { INTEGER | FRACTION | VECTOR | MATRIX | &quot;(&quot; ~ WHITE_SPACE* ~ EXPR ~ WHITE_SPACE* ~ &quot;)&quot; } EXPR_SHORT = { ATOM_EXPR_SHORT ~ (INFIX_OPS ~ ATOM_EXPR_SHORT)* } ATOM_EXPR_SHORT = { PREFIX_OPS ~ PRIMARY_EXPR ~ POSTFIX_OPS } PRIMARY_EXPR_SHORT = { INTEGER | FRACTION } TYPE = { INT_TYPE | FRAC_TYPE | VECTOR_TYPE | MATRIX_TYPE } INT_TYPE = { &quot;Int&quot; } FRAC_TYPE = { &quot;Frac&quot; } MATRIX_TYPE = { &quot;Mat&quot; | &quot;Matrix&quot; } VECTOR_TYPE = { &quot;Vec&quot; | &quot;Vector&quot; } PREFIX_OP = { &quot;abs&quot; | &quot;+&quot; | &quot;-&quot; } POSTFIX_OP = { &quot;!&quot; | &quot;^T&quot; } INFIX_OP = { MOD_OP | MUL_OP | ADD_OP } MOD_OP = { &quot;%&quot; | &quot;**&quot; } MUL_OP = { &quot;*&quot; | &quot;//&quot; } ADD_OP = { &quot;+&quot; | &quot;-&quot; } INTEGER = { ASCII_DIGIT+ } // FRACTION = { &quot;Frac&quot; ~ &quot;[&quot; ~ WHITE_SPACE* ~ EXPR_SHORT ~ WHITE_SPACE* ~ &quot;,&quot; ~ WHITE_SPACE* ~ EXPR_SHORT ~ WHITE_SPACE* ~ &quot;]&quot; } FRACTION = { &quot;Frac&quot; ~ &quot;[&quot; ~ WHITE_SPACE* ~ INTEGER ~ WHITE_SPACE* ~ &quot;,&quot; ~ WHITE_SPACE* ~ INTEGER ~ WHITE_SPACE* ~ &quot;]&quot; } MATRIX = { &quot;Mat&quot; ~ &quot;[&quot; ~ WHITE_SPACE* ~ MATRIX_ROWS ~ WHITE_SPACE* ~ &quot;]&quot; } MATRIX_ROWS = { VECTOR_ROW ~ (WHITE_SPACE* ~ &quot;,&quot; ~ WHITE_SPACE* ~ VECTOR_ROW)* } VECTOR = { &quot;Vec&quot; ~ VECTOR_ROW } // VECTOR_ROW = { &quot;[&quot; ~ WHITE_SPACE* ~ EXPR_SHORT ~ (WHITE_SPACE* ~ &quot;,&quot; ~ WHITE_SPACE* ~ EXPR_SHORT)* ~ WHITE_SPACE* ~ &quot;]&quot; } VECTOR_ROW = { &quot;[&quot; ~ WHITE_SPACE* ~ INTEGER ~ (WHITE_SPACE* ~ &quot;,&quot; ~ WHITE_SPACE* ~ INTEGER)* ~ WHITE_SPACE* ~ &quot;]&quot; } VAR = { &quot;var&quot; } 设计还很不完善，但是已经可以运行了，不枉三天功夫。 乐，明天早上还要交 代数 作业，，， 第二次记录：2024年12月28日子时 A Math Calculator implementation in Rust. MrMath = My Rust Math Calculator MrMath ├─ Cargo.lock ├─ Cargo.toml └─ src ├─ backend │ ├─ bigint │ │ ├─ fraction.rs │ │ ├─ matrix.rs │ │ └─ mod.rs │ ├─ driver.rs │ ├─ interpreter │ │ ├─ interpreter.rs │ │ └─ mod.rs │ ├─ mod.rs │ ├─ parser │ │ ├─ mod.rs │ │ └─ token.pest │ └─ structure │ ├─ ast.rs │ └─ mod.rs ├─ basic ├─ files │ ├─ manual │ │ ├─ fraction.txt │ │ ├─ integer.txt │ │ ├─ matrix.txt │ │ ├─ variable.txt │ │ └─ vector.txt │ └─ tables │ └─ keywords.txt ├─ frontend │ ├─ check.rs │ ├─ help.rs │ ├─ history.rs │ ├─ mod.rs │ └─ service.rs ├─ hello.rs └─ main.rs 添加了不少功能，实现了变量和常量，定义更加灵活，支持整数、分数、向量和矩阵的运算，分数、向量和矩阵的定义中可以包含部分复杂的表达式。 该去回头学理论泡论文写开题报告力。。。 估计后面会有一长段时间不碰这个了。","link":"2024/12/24/rust-2/"},{"title":"Rust 实现（一个弱智的）大整数计算","text":"后续：这个代码发现还是有不少问题的，但是博主很懒，所以有空再把调整后的代码放上来吧~ 前天学习了如何使用 rust，想随便写点东西练练手，就想着写一个简单的 Math Repl 吧。这是第一版（对的，还有第零版）的某个数学运算组件，正好没考虑效率地写完了可以进行测试，于是就有了这篇博客。 背景故事：第零版写着写着就开始在从头写定制的解释器（仅仅到条件语句），写到 AST 就破防了，感觉很笨重而且估计有些问题（虽然设定的一些测试过了），拼尽全力无法战胜（懒惰）于是第一版转战使用 pest ，舒服多了，但是需要先实现一下大整数计算，遂生此博客。 定义BigInt结构体 定义一个 BigInt 结构体来表示大整数。这个结构体包含一个 Vec&lt;i64&gt; 类型的字段 digits，用于存储大整数的各个位数。从低位到高位动态存储。 use std::cmp::Ordering; use std::ops::{Add, Sub, Mul, Div, Rem, Neg}; use fraction::Fraction; const BASE: i64 = 10; #[derive(Debug, Clone)] pub struct BigInt { digits: Vec&lt;i64&gt;, sign: bool, // false: positive, true: negative } impl BigInt { pub fn new(mut digits: Vec&lt;i64&gt;, sign: bool) -&gt; Self { while digits.len() &gt; 1 &amp;&amp; digits.last() == Some(&amp;0) { digits.pop(); } BigInt { digits, sign } } pub fn to_string(&amp;self) -&gt; String{ let sign = if self.sign { &quot;-&quot; } else { &quot;&quot; }; let digits = self.digits.iter().rev().map(|&amp;x| x.to_string()).collect::&lt;Vec&lt;_&gt;&gt;().join(&quot;&quot;); format!(&quot;{}{}&quot;, sign, digits) } } 实现基本运算 比较运算，PartialEq、Eq、PartialOrd 和 Ord 比较大整数。 impl PartialEq for BigInt { fn eq(&amp;self, other: &amp;Self) -&gt; bool { (self.digits == other.digits &amp;&amp; self.sign == other.sign) || (self.is_zero() &amp;&amp; other.is_zero()) } fn ne(&amp;self, other: &amp;Self) -&gt; bool { !self.eq(other) } } impl Eq for BigInt {} impl PartialOrd for BigInt { fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; { if self.sign != other.sign { return Some(if self.sign { Ordering::Less } else { Ordering::Greater }); } if self.digits.len() != other.digits.len() { return Some(self.digits.len().cmp(&amp;other.digits.len())); } Some(self.cmp(other)) } } impl Ord for BigInt { fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering { if self.sign != other.sign { return if self.sign { Ordering::Less } else { Ordering::Greater }; } let len_cmp = self.digits.len().cmp(&amp;other.digits.len()); if len_cmp != Ordering::Equal { return len_cmp; } for (a, b) in self.digits.iter().rev().zip(other.digits.iter().rev()) { let cmp = a.cmp(b); if cmp != Ordering::Equal { return cmp; } } Ordering::Equal } } 从String类型转换为BigInt。 impl From&lt;String&gt; for BigInt { fn from(mut s: String) -&gt; Self { let mut digits = Vec::new(); // remove zero while s.starts_with('0') &amp;&amp; s.len() &gt; 1 { s.remove(0); } for c in s.chars() { digits.push(c.to_digit(10).unwrap() as i64); } digits.reverse(); BigInt { digits, sign: false } } } 相反数运算 impl Neg for BigInt { type Output = Self; fn neg(self) -&gt; Self { BigInt { digits: self.digits, sign: !self.sign } } } 加法运算 impl Add for BigInt { type Output = Self; fn add(self, other: Self) -&gt; Self { if self.sign != other.sign { if self.digits == other.digits { return BigInt::zero(); } return self - (-other); } let mut result = Vec::new(); let mut carry = 0; let max_len = self.digits.len().max(other.digits.len()); for i in 0..max_len { let a = *self.digits.get(i).unwrap_or(&amp;0); let b = *other.digits.get(i).unwrap_or(&amp;0); let sum = a + b + carry; result.push(sum % BASE); carry = sum / BASE; } if carry &gt; 0 { result.push(carry); } while result.len() &gt; 1 &amp;&amp; result.last() == Some(&amp;0) { result.pop(); } BigInt { digits: result , sign: self.sign } } } 减法运算 impl Sub for BigInt { type Output = Self; fn sub(self, other: Self) -&gt; Self { if self.sign == other.sign &amp;&amp; self.digits == other.digits { return BigInt::zero(); } if self.sign != other.sign { return self + (-other); } let mut result = Vec::new(); let mut borrow = 0; let mut sign = self.sign; let (larger, smaller) = if self &gt;= other { (self, other) } else { sign = !self.sign; (other, self) }; for i in 0..larger.digits.len() { let a = *larger.digits.get(i).unwrap_or(&amp;0); let b = *smaller.digits.get(i).unwrap_or(&amp;0); let mut diff = a - b - borrow; if diff &lt; 0 { diff += BASE; borrow = 1; } else { borrow = 0; } result.push(diff); } while result.len() &gt; 1 &amp;&amp; result.last() == Some(&amp;0) { result.pop(); } BigInt { digits: result, sign } } } 乘法运算 impl Mul for BigInt { type Output = Self; fn mul(self, other: Self) -&gt; Self { let mut result = vec![0; self.digits.len() + other.digits.len()]; for (i, &amp;a) in self.digits.iter().enumerate() { let mut carry = 0; for (j, &amp;b) in other.digits.iter().enumerate() { let sum = result[i + j] + a * b + carry; result[i + j] = sum % BASE; carry = sum / BASE; } result[i + other.digits.len()] += carry; } while result.len() &gt; 1 &amp;&amp; result.last() == Some(&amp;0) { result.pop(); } BigInt { digits: result, sign: self.sign ^ other.sign } } } 除法运算 impl Div for BigInt { type Output = Self; fn div(self, other: Self) -&gt; Self { if other.digits.is_empty() || other.is_zero() { eprintln!(&quot;Warning: Division by zero&quot;); return BigInt::zero(); } let mut remainder = self.clone().abs(); let mut quotient = BigInt { digits: vec![], sign: self.sign ^ other.sign }; let mut divisor = other.abs(); if remainder &lt; divisor { return BigInt { digits: vec![0], sign: self.sign }; } let divisor_len = divisor.digits.len(); while divisor.digits.len() &lt; remainder.digits.len() { divisor.digits.insert(0, 0); } while divisor.digits.len() &gt;= divisor_len { let mut quotient_digit = 0; while remainder &gt;= divisor { remainder = remainder - divisor.clone(); quotient_digit += 1; } quotient.digits.insert(0, quotient_digit); divisor.digits.remove(0); } while quotient.digits.len() &gt; 1 &amp;&amp; quotient.digits.last() == Some(&amp;0) { quotient.digits.pop(); } quotient } } 取余运算 impl Rem for BigInt { type Output = Self; fn rem(self, other: Self) -&gt; Self { if other.digits.is_empty() || other.is_zero() { eprintln!(&quot;Warning: Division by zero&quot;); return BigInt::zero(); } if other.sign { eprintln!(&quot;Warning: The moduli cannot be negative!&quot;); return BigInt::zero(); } let mut remainder = self.clone().abs(); let mut divisor = other.clone().abs(); if remainder &lt; divisor { if self.sign &amp;&amp; !remainder.is_zero() { remainder = other.abs() - remainder; } return remainder; } let divisor_len = divisor.digits.len(); while divisor.digits.len() &lt; remainder.digits.len() { divisor.digits.insert(0, 0); } while divisor.digits.len() &gt;= divisor_len { while remainder &gt;= divisor { remainder = remainder - divisor.clone(); } divisor.digits.remove(0); } if self.sign &amp;&amp; !remainder.is_zero() { remainder = other.abs() - remainder; } remainder } } 其他 还为BigInt实现了一些其他有用的方法，例如幂运算、模幂运算、判断是否为零、判断是否为一、判断是否为负数、计算最大公约数（方便约分）、取绝对值和阶乘等等。 impl BigInt { pub fn zero() -&gt; Self { BigInt { digits: vec![0], sign: false } } pub fn one() -&gt; Self { BigInt { digits: vec![1], sign: false } } } impl BigInt { pub fn fraction(self, other: Self) -&gt; Fraction { if other.digits.is_empty() || other.is_zero() { eprintln!(&quot;Warning: Division by zero&quot;); return Fraction::zero(); } return Fraction::new(self, other); } pub fn pow(self, exp: u32) -&gt; Self { let mut base = self; let mut exp = exp; let mut result = BigInt::one(); while exp &gt; 0 { if exp % 2 == 1 { result = result * base.clone(); } base = base.clone() * base; exp /= 2; } result } pub fn mod_pow(self, exp: u32, modulus: Self) -&gt; Self { if modulus.digits.is_empty() || (modulus.digits.len() == 1 &amp;&amp; modulus.digits[0] == 0) { panic!(&quot;Modulus cannot be zero&quot;); } let mut base = self % modulus.clone(); let mut exp = exp; let mut result = BigInt::one() % modulus.clone(); while exp &gt; 0 { if exp % 2 == 1 { result = (result * base.clone()) % modulus.clone(); } base = (base.clone() * base) % modulus.clone(); exp /= 2; } result } pub fn is_zero(&amp;self) -&gt; bool { self.digits.is_empty() || (self.digits.len() == 1 &amp;&amp; self.digits[0] == 0) } pub fn is_one(&amp;self) -&gt; bool { self.digits.len() == 1 &amp;&amp; self.digits[0] == 1 } pub fn is_negative(&amp;self) -&gt; bool { self.digits.first().map_or(false, |&amp;digit| digit &lt; 0) } pub fn gcd(&amp;self, other: &amp;Self) -&gt; Self { let mut a = self.clone().abs(); let mut b = other.clone().abs(); while !b.is_zero() { let temp = b.clone(); b = a % b; a = temp; } a } pub fn abs(mut self) -&gt; Self { self.sign = false; self } pub fn factorial(self) -&gt; Self { if self.is_negative() { eprintln!(&quot;Warning: Factorial of a negative number is undefined&quot;); return BigInt::zero(); } let mut result = BigInt::one(); let mut i = BigInt::one(); while i &lt;= self.clone() { result = result * i.clone(); i = i + BigInt::one(); } result } } 测试 编写了一些测试用例来验证BigInt的各种功能。 #[cfg(test)] mod tests { use crate::backend::bigint::BigInt; #[test] fn test_creation() { let bigint = BigInt { digits: vec![1, 2, 3], sign: false }; assert_eq!(bigint.digits, vec![1, 2, 3]); } #[test] fn test_comparison() { let a = BigInt { digits: vec![1, 2, 3], sign: false }; let b = BigInt { digits: vec![1, 2, 3], sign: false }; assert_eq!(a, b); let c = BigInt { digits: vec![1, 2, 4], sign: false }; assert_ne!(a, c); assert!(a &lt; c); let d = BigInt { digits: vec![1, 9], sign: false }; assert!(a &gt; d); let e = BigInt { digits: vec![1, 2, 3], sign: true }; assert!(e &lt; a); } #[test] fn test_negation() { let a = BigInt { digits: vec![1, 2, 3], sign: false }; let result = -a; assert_eq!(result.digits, vec![1, 2, 3]); assert_eq!(result.sign, true); } #[test] fn test_addition() { let a = BigInt { digits: vec![6, 2, 3], sign: false }; let b = BigInt { digits: vec![4, 5, 6], sign: false }; let result = a + b; assert_eq!(result.digits, vec![0, 8, 9]); assert_eq!(result.sign, false); let d = BigInt { digits: vec![1, 2, 3], sign: false }; let c = BigInt { digits: vec![1, 2, 3], sign: true }; let result = d + c; assert_eq!(result, BigInt::zero()); let e = BigInt { digits: vec![1, 2, 3], sign: true }; let f = BigInt { digits: vec![1, 2, 2], sign: false }; let result = e + f; assert_eq!(result.digits, vec![0, 0, 1]); assert_eq!(result.sign, true); } #[test] fn test_subtraction() { let a = BigInt { digits: vec![5, 1, 9], sign: false }; let b = BigInt { digits: vec![1, 2, 3], sign: false }; let result = a - b; assert_eq!(result.digits, vec![4, 9, 5]); assert_eq!(result.sign, false); let a = BigInt { digits: vec![1, 2, 3], sign: false }; let b = BigInt { digits: vec![5, 1, 9], sign: false }; let result = a - b; assert_eq!(result.digits, vec![4, 9, 5]); assert_eq!(result.sign, true); let a = BigInt { digits: vec![1, 2, 3], sign: true }; let b = BigInt { digits: vec![1, 2, 3], sign: false }; let result = a - b; assert_eq!(result.digits, vec![2, 4, 6]); assert_eq!(result.sign, true); let a = BigInt { digits: vec![1, 2, 3], sign: false }; let b = BigInt { digits: vec![1, 3, 3], sign: false }; let result = a - b; assert_eq!(result.digits, vec![0, 1]); assert_eq!(result.sign, true); } #[test] fn test_multiplication() { let a = BigInt { digits: vec![1, 2, 3], sign: false }; let b = BigInt { digits: vec![4, 5, 6], sign: false }; let result = a * b; assert_eq!(result.digits, vec![4, 3, 9, 9, 0, 2]); assert_eq!(result.sign, false); let a = BigInt { digits: vec![1, 2, 3], sign: true }; let b = BigInt { digits: vec![4, 5, 6], sign: false }; let result = a * b; assert_eq!(result.digits, vec![4, 3, 9, 9, 0, 2]); assert_eq!(result.sign, true); } #[test] fn test_division() { let a = BigInt { digits: vec![1, 2, 3], sign: false }; let b = BigInt { digits: vec![3], sign: false }; let result = a / b; assert_eq!(result.digits, vec![7, 0, 1]); assert_eq!(result.sign, false); let a = BigInt { digits: vec![1, 2, 3], sign: true }; let b = BigInt { digits: vec![4], sign: false }; let result = a / b; assert_eq!(result.digits, vec![0, 8]); assert_eq!(result.sign, true); // let a = BigInt { digits: vec![1, 2, 3], sign: false }; // let b = BigInt { digits: vec![0], sign: false }; // let result = a / b; // println!(&quot;{:?}&quot;, result); } #[test] fn test_remainder() { let a = BigInt { digits: vec![1, 2, 3], sign: false }; let b = BigInt { digits: vec![1, 2], sign: false }; let result = a % b; assert_eq!(result.digits, vec![6]); let c = BigInt { digits: vec![1, 2, 4], sign: false }; let a = BigInt { digits: vec![1, 2, 3], sign: false }; let result = c % a; assert_eq!(result.digits, vec![0, 0, 1]); let d = BigInt { digits: vec![1, 2, 3], sign: true }; let e = BigInt { digits: vec![1, 2, 3], sign: false }; let result = d % e; assert_eq!(result.digits, vec![0]); let d = BigInt { digits: vec![1, 2, 4], sign: true }; let e = BigInt { digits: vec![1, 2, 3], sign: false }; let result = d % e; assert_eq!(result.digits, vec![1, 2, 2]); assert_eq!(result.sign, false); } #[test] fn test_pow() { let a = BigInt { digits: vec![2, 2], sign: false }; let result = a.pow(3); assert_eq!(result.digits, vec![8, 4, 6, 0, 1]); assert_eq!(result.sign, false); let a = BigInt { digits: vec![2, 2], sign: true }; let result = a.pow(3); assert_eq!(result.digits, vec![8, 4, 6, 0, 1]); assert_eq!(result.sign, true); } #[test] fn test_mod_pow() { let a = BigInt { digits: vec![2, 1], sign: false }; let b = BigInt { digits: vec![9, 9], sign: false }; let result = a.mod_pow(3, b); assert_eq!(result.digits, vec![5, 4]); assert_eq!(result.sign, false); let a = BigInt { digits: vec![2, 1], sign: true }; let b = BigInt { digits: vec![9, 9], sign: false }; let result = a.mod_pow(3, b); assert_eq!(result.digits, vec![4, 5]); assert_eq!(result.sign, false); } #[test] fn test_is_zero() { let a = BigInt { digits: vec![0], sign: false }; assert!(a.is_zero()); let b = BigInt { digits: vec![1], sign: false }; assert!(!b.is_zero()); } #[test] fn test_is_one() { let a = BigInt { digits: vec![1], sign: false }; assert!(a.is_one()); let b = BigInt { digits: vec![0], sign: false }; assert!(!b.is_one()); } #[test] fn test_is_negative() { let a = BigInt { digits: vec![-1], sign: false }; assert!(a.is_negative()); let b = BigInt { digits: vec![1], sign: false }; assert!(!b.is_negative()); } #[test] fn test_gcd() { let a = BigInt { digits: vec![2, 2], sign: false }; let b = BigInt { digits: vec![3, 3], sign: false }; let result = a.gcd(&amp;b); assert_eq!(result.digits, vec![1, 1]); assert_eq!(result.sign, false); let a = BigInt { digits: vec![3, 3], sign: true }; let b = BigInt { digits: vec![2, 2], sign: false }; let result = a.gcd(&amp;b); assert_eq!(result.digits, vec![1, 1]); assert_eq!(result.sign, false); let a = BigInt { digits: vec![3, 3], sign: true }; let b = BigInt { digits: vec![3, 3], sign: false }; let result = a.gcd(&amp;b); assert_eq!(result.digits, vec![3, 3]); assert_eq!(result.sign, false); } #[test] fn test_abs() { let a = BigInt { digits: vec![1, 2, 3], sign: false }; let result = a.abs(); assert_eq!(result.digits, vec![1, 2, 3]); assert_eq!(result.sign, false); let b = BigInt { digits: vec![1, 2, 3], sign: true }; let result = b.abs(); assert_eq!(result.digits, vec![1, 2, 3]); assert_eq!(result.sign, false); } #[test] fn test_comparison_with_zero() { let a = BigInt { digits: vec![1, 2, 3], sign: false }; let b = BigInt { digits: vec![0], sign: false }; assert!(a &gt; b); } #[test] fn test_comparison_with_negative_zero() { let a = BigInt { digits: vec![0], sign: false }; let b = BigInt { digits: vec![-0], sign: false }; assert!(a == b); } #[test] fn test_from_str() { let a = BigInt::from(&quot;123&quot;.to_string()); assert_eq!(a.digits, vec![3, 2, 1]); let b = BigInt::from(&quot;00123&quot;.to_string()); assert_eq!(b.digits, vec![3, 2, 1]); let c = BigInt::from(&quot;0&quot;.to_string()); assert_eq!(c.digits, vec![0]); let d = BigInt::from(&quot;0000&quot;.to_string()); assert_eq!(d.digits, vec![0]); let e = BigInt::from(&quot;9876543210&quot;.to_string()); assert_eq!(e.digits, vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9]); } #[test] fn test_factorial() { let a = BigInt { digits: vec![0, 1], sign: false }; let result = a.factorial(); println!(&quot;{}&quot;, result.to_string()); } } 测试结果：","link":"2024/12/23/rust-1/"},{"title":"welcome_2025","text":"2025年1月22日清晨回乡的路上，打开软件，听到的第一首歌就是王菲的新歌。朴素轻柔的旋律入耳，倒是没反应过来是新的曲子。路上有些嘈杂，便调高了一些音量。 词曲直白，充满着烟火气，笔者很受感触（虽然网络上褒贬不一）。 .custom-audio { display: flex; align-items: center; justify-content: center; width: 160px; height: 40px; background-color: #f0f8ff; border-radius: 0; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); padding: 5px; } .custom-audio button { background-color: #87cefa; border: none; border-radius: 15%; width: 30px; height: 30px; cursor: pointer; outline: none; } .custom-audio button:hover { background-color: #add8e6; } .custom-audio audio { display: none; } ►&nbsp;世界赠予我的-王菲 function togglePlay() { const audio = document.getElementById(\"myAudio\"); const button = document.querySelector(\".custom-audio button\"); if (audio.paused) { audio.play(); button.innerHTML = \"❚❚\"; } else { audio.pause(); button.innerHTML = \"►\"; } } togglePlay();","link":"2025/01/23/welcome-2025/"}],"tags":[{"name":"Algebra","slug":"Algebra","link":"tags/Algebra/"},{"name":"Math","slug":"Math","link":"tags/Math/"},{"name":"计算复杂性","slug":"计算复杂性","link":"tags/计算复杂性/"},{"name":"Lean4","slug":"Lean4","link":"tags/Lean4/"},{"name":"Coding","slug":"Coding","link":"tags/Coding/"},{"name":"UCATFLAGS","slug":"UCATFLAGS","link":"tags/UCATFLAGS/"},{"name":"Crypto","slug":"Crypto","link":"tags/Crypto/"},{"name":"CTF","slug":"CTF","link":"tags/CTF/"},{"name":"NumberTheory","slug":"NumberTheory","link":"tags/NumberTheory/"},{"name":"Rust","slug":"Rust","link":"tags/Rust/"}],"categories":[]}