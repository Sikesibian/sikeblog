{"pages":[{"title":"404","text":"","link":"404/index.html"},{"title":"About","text":"随意留言。","link":"about/index.html"},{"title":"","text":"","link":"links/links.html"},{"title":"Untagged","text":"","link":"tags/Untagged.html"},{"title":"Tags","text":"","link":"tags/index.html"}],"posts":[{"title":"Lean4-1 —— Lean4 的基本使用","text":"上一篇：Lean4-0 —— Lean4 的安装 这里假定大家有一定C语言、Python基础。 注释：单行注释：-- 注释，多行注释：/- 多行注释 -/。下面的代码中会使用注释来标记代码的解释说明或者Lean的返回结果。Lean是很方便的，它往往能实时向我们返回结果。 1. Lean4 中的声明、检查与求值 下面先列出对应的关键字： 声明（Define） def：用于声明一个新的常量 检查（Check） #check：用于检查一个对象的类型 求值（Evaluate） #eval：用于计算给出的表达式 以井号开头的都是用于向Lean系统询问信息的辅助命令，比如这里的 #check 和 #eval。 例子： 123456789/- 定义常数 -/def m : Nat := 1def b : Bool := true/- 检查类型 -/#check m#check b/- 求值 -/#eval m + 6#eval b &amp;&amp; false 2. Lean4 的基本使用 Lean中的任意表达式都有一个类型。 Lean是用于构建复杂表达式的工具，基于 依值类型论（Dependent Type Theory） 这一形式语言。 2.0 依值类型论 类型论是一类基于 λ\\lambdaλ 演算的形式理论的统称，所有数学对象都有各自的类型。而依值类型论是一种类型的定义可以依赖于值（由值所推断）的类型论，可以写成： Γ⊢A type\\Gamma \\vdash A\\text{ type} Γ⊢A type 依值类型论的一些概念并不容易理解，但是我们可以将依值类型论和我们熟知的数理逻辑作如下对应（但不能完全等同）： 数理逻辑 依值类型论 语境 语境 命题 类型 命题宇宙 宇宙 全称量词 Π\\PiΠ 类型（积类型） 存在量词 Σ\\SigmaΣ 类型（和类型） 语境：相继式 ⊢\\vdash⊢ 左边的部分，也称上下文或先决条件。 类型：类似于集合，但与集合不同。类型直接通过规则定义。 宇宙：可以理解为“类型的类型”，虽然这样并不准确。 Σ\\SigmaΣ 类型：定义的一种新类型，类似于将类型合并整合成一个新类型。如C语言中的联合体。 Π\\PiΠ 类型：定义的一种新类型，展现出来的类型随输入实例类型变化。如C语言中的结构体。 2.1 Lean4 编程基础 万物皆函数。 2.1.1 Lean4 的 “Hello, World!” 函数的形式 在我们学习C语言等高级语言时，函数往往都写成 func(x) 的形式，而在 Lean （或 Haskell、Lisp 等）语言中朋友们应当习惯直接将参数写在函数后面： 1#eval String.append &quot;Hello, &quot; &quot;World!&quot; 实际上实现的效果就是：String.append(&quot;Hello, &quot;, &quot;World&quot;)，但是这样写语法并不正确，所以这里用一根删除线划掉 当然你也可以类似 Python 点号标记来调用函数的写法： 1#eval &quot;Hello, &quot;.append &quot;World!&quot; 这样的函数也是有一定执行顺序的，比如对比下面两个语句： 1234-- #eval String.append String.append &quot;Hello&quot; &quot;, &quot; &quot;world!&quot; （不可执行）#eval String.append (String.append &quot;Hello&quot; &quot;, &quot;) &quot;world!&quot;-- #eval String.append &quot;Hello&quot; String.append &quot;, &quot; &quot;world!&quot; （不可执行）#eval String.append &quot;Hello&quot; (String.append &quot;, &quot; &quot;world!&quot;) 而这个函数的值就是这个表达式所计算出来的值。 条件表达式（ITE表达式） ITE表达式即 If-Then-Else 表达式，实际上就类似于 C语言 中的三目运算符 ; ? 或 Python 中的 &lt;statement1&gt; if &lt;condition&gt; else &lt;statement2&gt; ，那么在Lean中就有： 123456#eval String.append &quot;Oh! &quot; (if 1 &gt; 2 then &quot;Yes!&quot; else &quot;No!&quot;)--&gt;#eval String.append &quot;Oh! &quot; (if false then &quot;Yes!&quot; else &quot;No!&quot;)--&gt;#eval String.append &quot;Oh! &quot; &quot;No!&quot;--&gt; &quot;Oh! No!&quot; 定义 功能 例子 效果 定义常量 def YES := &quot;Yes!&quot; #eval String.append &quot;Oh! &quot; YES 定义函数（单元） def succ1 (n : Nat) : Nat := n + 1 #eval succ1 6 定义函数（多元） def succk (n : Nat) (k : Nat) : Nat := n + k #eval succk 3 6 定义类型（类似于 typedef ） def Str : Type := String def HELLO : Str := &quot;Hello, World!&quot; 注：Nat 表示自然数，Type 表示“类型的类型” 不过可能遇到下面这个问题，首先定义： 1def NaturalNum : Type := Nat 那么下面这段代码就会报错： 1def sixteen : NatrualNum := 16 -- Wrong! 这是因为 16 被认为是歧义的，我们需要指定右边 16 的类型，即重载（Overload）： 1def sixteen : NatrualNum := (16 : Nat) -- Right! 当然你也可以使用 abbrev 关键字来解决这个问题： 12abbrev NNNNat : Type := Natdef sixteen' : NNNNat := 16 而像 abbrev 生成的定义会被标记为可约（Reducible）定义，即可展开的定义，而当我们完全展开所有定义可能会产生十分大的类型（正如第一小节依值类型论所涉及到的），控制这种可约定义对 Lean 的灵活性有着关键作用。 2.1.2 柯里化（Currying） 柯里化指的是把接受多个参数的函数转换成接受单个参数的函数，可以理解为每接受一个参数就产生一个新函数，即逐个带入函数的参数（即使用返回函数的函数来实现多参数函数），以数学家哈斯克尔·柯里（Haskell Curry）命名。柯里化能够一定程度上解决重复传参问题，提高函数适用性。 在Python中考虑这样形式的函数（虽然我们并不建议使用Python中lambda表达式语法糖）： 1add3 = lambda x, y, z: x + y + z 柯里化后会形如： 1add3_ = lambda x: lambda y: lambda z: x + y + z 这里Python中 add3(1, 2, 3) 就与 add3_(1)(2)(3) 一致。 下面来谈谈 Lean 中的柯里化。观察下面这个多元输入函数： 12def mycurrying (n : Nat) (k : String) : Int := n + (String.length k) 使用#check 语句，用小括号来包裹住函数名称使其显示函数类型，得到如下结果： 123#check (mycurrying) -- mycurrying : Nat → String → Int#check (mycurrying 3) -- mycurrying 3 : String → Int#check (mycurrying 3 &quot;Hello&quot;) -- mycurrying 3 &quot;Hello&quot; : Int 第一行 mycurrying 是一个接受自然数和字符串，返回整数的函数。类型表示为 Nat → String → Int，表示函数依次接受一个自然数和字符串，最后返回一个整数。 第二行 mycurrying 3 表达式整体被视为一个接受字符串，返回整数的函数。类型表示为 String → Int，表示函数依次接受一个字符串，最后返回一个整数。 第三行 mycurrying 3 &quot;Hello&quot; 表示在提供了所有参数 3 和 &quot;Hello&quot; 之后，mycurrying 函数的类型。此时，它直接返回一个整数 Int。 Lean4 中，函数的柯里化是默认的，也就是说，函数的参数是从左到右的，而函数的返回值是从右到左即右结合的（即Nat → String → Int 所表达的就是 Nat → (String → Int) ，即 Nat 返回一个 String → Int 的函数）。 如果我们把类型看做命题，那么只有接受了正确类型的值（类型由值推导），才能获得下一步的函数，也就是说我们可以把其中连接类型的箭头 → 看做蕴含或者推导符号。 2.1.3 数据类型 Lean 基本类型：Nat, Int, String, Char, Bool, Float, … Lean 标准库内置类型：List（链表），Option（可选类型），Prod（积类型），Sum（和类型），Unit（单位类型），Empty（空类型）… 自定义数据类型：Structure（结构体），Inductive（归纳类型）… 在这一篇中我们主要只介绍 structure 和 inductive 两种类型。更多内容，包括多态（Polymorphism），将在后续文章中进行介绍。 结构体（Structure） 下面以平面坐标的一个点为例。一个平面坐标中的点由x和y两个坐标唯一确定，因此可以通过下面的Lean代码构建这样的一个表示平面坐标中点的结构体： 123structure Point where x : Float y : Float structure 关键字定义了一个新的数据类型，其中 x 和 y 是结构体的字段，它们是结构体中包含的数据。如果你希望在#eval 的时候能够显示求值结果，那么请在上述代码后面加上 deriving Repr（类似于Python 的 __repr__ 函数）。即： 1234structure Point where x : Float y : Floatderiving Repr deriving Repr 是一个 Lean4 的关键字，它表示在结构体中定义的每个字段都会被自动生成一个 Repr 实例，即 Repr 实例会自动生成一个 toString 方法，该方法会将结构体中的每个字段转换为字符串，并使用逗号分隔。 A. 创建结构体类型值 直接创建：def P1 : Point := { x := 1.0, y := 2.0 } 构造子（Constructor）：收集要存储在新分配的数据结构中的数据，如上面 Point 结构体的构造子是 Point.mk 这个默认名称。上面直接创建的方式，就等价于 def P1 : Point := Point.mk 1.0 2.0。而若要覆盖默认名称 mk，则需要写成如下形式： 1234structure Point where newpoint :: x : Float y : Float B. 访问结构体字段 点号表记法：访问 x 和 y 字段：P1.x 和 P1.y 例子，点的欧氏距离函数： 12def distance (p1 p2 : Point) : Float := Float.sqrt ((p2.x - p1.x) ^ 2.0 + (p2.y - p1.y) ^ 2.0) C. 结构体更新 更新在 Lean 中其实与其在其他语言中含义并不太一样，在其他语言中这意味着对应的内存位置被新的值覆盖，但是Lean 是没有可变状态的，即说明 Lean 中的更新相当于分配了一个新的 Point （在此例中）。 使用 with 关键字来替换结构体中的一些字段，例子如下： 12345def updateX (p : Point) (x' : Float) : Point := { p with x := x'}-- 等价于def updateX' (p : Point) (x' : Float) : Point := { x := x', y := p.y } 再次注意，Lean 中结构体的更新并没有修改原有结构体实例的值。 和类型、递归类型（Recursive Type）、归纳类型（Inductive Type） Σ\\SigmaΣ 类型/和类型：可以理解为可以选择的类型 递归类型：可以包含自身实例的类型。 归纳类型：递归类型 + 和类型 下面就是一个归纳类型的例子，它表示一个图形，可以是一个点，也可以是直线，也可以是圆。 12345inductive Shape where | point : Point → Shape | line : Point → Point → Shape | circle : Point → Float → Shapederiving Repr -- 加上使得我们能够 #eval 它 下面是一个使用的例子： 1234#check Shape -- Shape : Type#eval Shape.circle origin 3.0-- 也相当于#eval Shape.circle (Point.mk 0.0 0.0) 3.0 Lean 中使用**模式匹配（Pattern Matching）**来处理一些诸如类型判断，然后分别处理等任务。如下例子所示： 123456def area (s : Shape) : Float := match s with | Shape.point _ =&gt; 0.0 | Shape.line _ _ =&gt; 0.0 | Shape.circle _ r =&gt; Pi * r * r where Pi := 3.141592653589793 match 关键字根据模式来匹配一个值，然后执行相应的代码块。这里代码的意义就是，match 判断 s 属于 Shape 中的哪一类： Shape.point，则返回 0.0 Shape.line，则返回 0.0 Shape.circle，则返回 Pi * r * r，其中 Pi 是一个局部变量，r 是 Shape.circle 中的一个字段。 而这里的 _ 相当于一个参数的占位符，往往用于表示忽略该字段。where 关键字定义了一个局部变量，它只在当前函数内部可见。 值得一提的是，Lean 提供了不少简洁的写法，比如上面的 area 函数和下面这个 area' 函数是等价的： 12345def area' : Shape → Float | Shape.point _ =&gt; 0.0 | Shape.line _ _ =&gt; 0.0 | Shape.circle _ r =&gt; Pi * r * r where Pi := 3.141592653589793 你可以对多变元函数的某个变元进行匹配： 12345def PointOnCircle (c : Shape) (p : Point) : Prop := match c with | Shape.circle o r =&gt; (p.x - o.x) ^ 2 + (p.y - o.y) ^ 2 = r ^ 2 | _ =&gt; false 也可以对多变元函数的多个变元进行匹配： 12345def PointOnLine (l : Shape) (p : Point) : Prop := match l with | Shape.line p1 p2 =&gt; (p.x - p1.x) * (p2.y - p1.y) - (p.y - p1.y) * (p2.x - p1.x) = 0 | _ =&gt; false 这里的两个函数 PointOnCircle 和 PointOnLine 与我们刚刚定义的函数有点不同，它们是无法 #eval 的，这是因为它们返回的是一个 Proposition，即一个命题类型（Prop），而命题无法求值。 匿名函数 Lean中也允许函数不在顶层被定义，它允许定义一种被称为匿名函数（anonymous function）的东西，使用的是关键字 fun 或者 λ。 如下面这个例子： 12#check fun x : Nat =&gt; x + 1 -- fun x =&gt; x + 1 : Nat → Nat#check λ x : Nat =&gt; x + 1 -- fun x =&gt; x + 1 : Nat → Nat 事实上匿名函数的使用方式和一般的 def 所定义的函数完全一致，就是没有函数名的函数。 下面是一个更加复杂一点的例子： 1#check λ hpc : PointOnCircle (Shape.circle origin 5.0) (Point.mk 3.0 4.0) =&gt; sorry 这里函数变量 hpc 的类型就是 PointOnCircle (Shape.circle origin 5.0) (Point.mk 3.0 4.0)的实例化，虽然后面使用了sorry 来作为占位符，但实际上=&gt;后面我们就可以使用 hpc 这个变量，来表示 hpc 这个命题了。 证明一个定理 在上一部分中其实还有许许多多可以聊的内容，但是我想在这里可以聊一聊如何利用Lean 来证明一个定理。 回忆一下，我们说，Lean 中的类型与数理逻辑中的命题相对应，Lean 通过对类型的推断来证明定理。 在本篇内容的前半部分，我们定义了下面几个东西： 123456#check Point -- Point : Type#check Shape -- Shape : Type#check PointOnCircle -- PointOnCircle (c : Shape) (p : Point): Prop#check (PointOnCircle) -- PointOnCircle : Shape → Point → Prop#check PointOnLine -- PointOnLine (l : Shape) (p : Point): Prop#check (PointOnLine) -- PointOnLine : Shape → Point → Prop 下面我们证明一个定理： 若一个点在一个圆上，且这个点也在一条直线上，则该点同时在直线和圆上。 注：其实这里就是一个重言式的例子，不过为了方便，我们给了它这样的一个情境。 定理的描述 将上述命题在 Lean 中表达出来即： 1234theorem PointOnCircleOnLine (c : Shape) (l : Shape) (p : Point) : PointOnCircle c p → PointOnLine l p → PointOnCircle c p ∧ PointOnLine l p := sorry theorem 关键字定义了一个定理，它和 def 的区别在于，theorem 直接是一个不可求值的命题，而 def 是一个可求值的函数。 另外，sorry 是一个占位符，表示我们暂时还没有证明这个命题。 假设 theorem 的名字是 PointOnCircleOnLine，那么 PointOnCircleOnLine 的内容就被视为一个命题，而 PointOnCircleOnLine c l p 就是一个命题的实例。如下所示： 1#check PointOnCircleOnLine Lean Infoview中反馈到我们： 12PointOnCircleOnLine (c l : Shape) (p : Point) : PointOnCircle c p → PointOnLine l p → PointOnCircle c p ∧ PointOnLine l p 传入一个参数 Shape.circle (Point.mk 0.0 0.0) 3.0： 1#check PointOnCircleOnLine (Shape.circle (Point.mk 0.0 0.0) 3.0) 注：柯里化。 Lean Infoview中反馈到我们： 12345PointOnCircleOnLine (Shape.circle { x := 0.0, y := 0.0 } 3.0) : ∀ (l : Shape) (p : Point), PointOnCircle (Shape.circle { x := 0.0, y := 0.0 } 3.0) p → PointOnLine l p → PointOnCircle (Shape.circle { x := 0.0, y := 0.0 } 3.0) p ∧ PointOnLine l p 定理的证明 数学上大致证明过程如下： 12345678theorem PointOnCircleOnLine (c : Shape) (l : Shape) (p : Point) : PointOnCircle c p → PointOnLine l p → PointOnCircle c p ∧ PointOnLine l p := -- 假设 p 在 c 上，并且 p 在 l 上 -- 证明 p 在 c 和 l 上 -- 证明完成 sorry 在 Lean4 中它所对应的代码就如下所示： 12345678910111213theorem PointOnCircleOnLine (c : Shape) (l : Shape) (p : Point) : PointOnCircle c p → PointOnLine l p → PointOnCircle c p ∧ PointOnLine l p := -- 假设 p 在 c 上，并且 p 在 l 上 λ hpc : PointOnCircle c p =&gt; λ hpl : PointOnLine l p =&gt; have hp : PointOnCircle c p := hpc have hl : PointOnLine l p := hpl -- 证明 p 在 c 和 l 上 show PointOnCircle c p ∧ PointOnLine l p -- 证明目标 from And.intro hp hl -- 证明过程 -- 证明完成 λ 关键字：表示一个 lambda 表达式/匿名函数，是Lean中未在顶层定义的函数，可以理解为就是一个表达式。Lean中 的 λ 关键字 和 fun 是一致的，虽然你常常看到的是 fun。 hpc 和 hpl：表示 hpc 是 PointOnCircle c p 的一个实例，表示对应的命题 PointOnCircle c p，而 hpl 是 PointOnLine l p 的一个实例，亦表示了对应的命题 PointOnLine l p。 have 关键字：用来引入一个新的局部假设或结论的关键字。在证明中，可以使用 have 来声明一个中间步骤，然后这个步骤就可以在后面被引用。比如这里的have hp : PointOnCircle c p := hpc，hp 就是一个局部假设，它表示 hpc 的值。 show 关键字：用来明确指出证明的目标类型的关键字。这里 show PointOnCircle c p ∧ PointOnLine l p 就指出证明的目标是展示点同时在圆上和线上。 from 关键字：用来指定证明过程的关键字。这里 from And.intro hp hl 就使用 And.intro 证明了点同时在圆上和线上。 And.intro：用来构造一个 PointOnCircle c p ∧ PointOnLine l p 的值，同时也就证明了我们需要的命题。 让我们回顾一些理解关键点： Lean 中 Prop 类型和数理逻辑中的命题相对应。值和类型可以看做是等价的（依值类型）。 函数的参数（的类型）可以看做初始条件；函数的返回值（的类型）可以看做目标条件。比如上述例子中的 PointOnCircle c p → PointOnLine l p →，PointOnCircle c p 和 PointOnLine l p 都是初始条件，而 PointOnCircle c p ∧ PointOnLine l p 是目标条件。 我们根据给到的传入参数值构造新的中间变量，这些中间变量的类型就是我们产生的中间命题。 have 关键字可以引入新的局部假设或结论，而 show 关键字可以明确指出证明的目标类型，from 关键字则可以指定证明过程。 更进一步 如果进一步定义两个图形的交点： 1234567891011def Intersects (c1 c2 : Shape) (p : Point) : Prop := match c1, c2 with | Shape.circle _ _, Shape.circle _ _ =&gt; PointOnCircle c1 p ∧ PointOnCircle c2 p | Shape.circle _ _, Shape.line _ _ =&gt; PointOnCircle c1 p ∧ PointOnLine c2 p | Shape.line _ _, Shape.circle _ _ =&gt; PointOnCircle c2 p ∧ PointOnLine c1 p | Shape.line _ _, Shape.line _ _ =&gt; PointOnLine c1 p ∧ PointOnLine c2 p | _, _ =&gt; false 前面证明的定理的描述可以转换为： 若一个点在一个圆上，且这个点也在一条直线上，则该点为直线和圆的交点。 类似地可以给出如下定理及其证明： 12345678910111213theorem PointOnCircleOnLine' (c : Shape) (l : Shape) (p : Point) : PointOnCircle c p → PointOnLine l p → -- 条件：假设 p 在 c 上，并且 p 在 l 上 Intersects c l p := -- 目标：证明 p 是 c 和 l 的交点 λ hpc : PointOnCircle c p =&gt; -- 实例化条件 hpc：p 在 c 上 λ hpl : PointOnLine l p =&gt; -- 实例化条件 hpl：p 在 l 上 have hp : PointOnCircle c p := hpc -- 引入新的局部假设 hp，由 hpc 诱导出 have hl : PointOnLine l p := hpl -- 引入新的局部假设 hl，由 hpl 诱导出 match c, l with -- 匹配 c 和 l 的类型，确保其在后续使用 Intersects 的时候具体类型是匹配的 | Shape.circle o1 r1, Shape.line p1 p2 =&gt; -- 匹配到 c 和 l 的具体类型 show Intersects (Shape.circle o1 r1) (Shape.line p1 p2) p from -- 证明目标 And.intro hp hl -- 证明过程，构造一个 PointOnCircle c p ∧ PointOnLine l p 的值，其与 Intersects c l p 类型一致，也就证明了这个命题 这里我们并不能直接使用 show Intersects c l p，因为 Lean4 的 show 关键字只能显式地指明目标类型，而 Intersects c l p 的类型是隐式地推导出来的，所以需要显示地指明。即 Lean4 会认为这里的 c, l 的类型是 Shape，而非期待的Shape.circle 和 Shape.line。","link":"2024/12/09/Lean4-1/"},{"title":"Lean4-0 —— Lean4 的安装","text":"下一篇：Lean4-1 —— Lean4 的基本使用 VSCode 中安装 Lean 4 VSCode中安装扩展： 跟随右侧导航走即可： 记得给 elan 设置一下环境变量，elan 一般在这个文件夹下（C:\\User\\&lt;User Name&gt;\\.elan\\bin\\）： 编写一个测试文件： 点击右侧 ∀\\forall∀ 符号，选择 Toggle Infoview 可以看到一些预览信息（或快捷键 Ctrl+Shift+Enter： Lean 4 项目的创建 我们使用 lake 进行项目的创建 注（引用自：Lean4 - Mathlib4 / 用于形式化数学的准备 (1) - 知乎，Lean4 安装教程 - Lean Prover 中文文档）： lake：Lean 4 的包管理器，全称 Lean Make，已合并到 Lean 4 仓库，作为源码的一部分。它用于创建 Lean 项目，构建 Lean 包，配置 Mathlib 和编译 Lean 可执行文件。 elan：Lean 环境版本管理器。它的功能类似于 Rust 的 rustup 或 Node.js 的 nvm，用于安装、管理和切换不同版本的 Lean。 然后可以使用以下命令进行项目 1lake new basic 这样就建立了一个名为 basic 的项目，它的结构是这样的： 123456789basic├─ Basic│ └─ Basic.lean├─ Basic.lean├─ lake-manifest.json├─ lakefile.toml├─ lean-toolchain├─ Main.lean└─ README.md 或者你也可以选择在某个文件夹下直接运行 lake init 进行初始化。 接下来就可以使用 lake 来将 Lean 4 程序转换为可执行程序了： 1lake build 你观察项目文件目录结构会发现恰好多了一个 ./lake 文件夹。接下来就是运行： 1lake exec hello 总结 lake 常见用法如下所示： 1234567891011121314# 构建新项目lake new &lt;project_name&gt;# 在当前文件夹初始化新项目lake init# 构建项目可执行文件lake build# 运行lake exec &lt;project_name&gt;# 清理构建文件lake clean# 更新依赖lake update# 运行 lakefile.lean 的脚本lake run &lt;script&gt; 包的引用 注意到初始化好的项目中有一个文件 leanfile.toml ，这是一个配置文件，我们可以在其中进行引用的管理，格式如下： 123456789101112131415161718# A Reservoir dependency[[require]]name = &quot;&lt;pkg-name&gt;&quot;scope = &quot;&lt;scope&gt;&quot;version = &quot;&lt;version&gt;&quot;options = {&lt;options&gt;}# A path dependency[[require]]name = &quot;&lt;pkg-name&gt;&quot;path = &quot;&lt;path&gt;&quot;# A Git dependency[[require]]name = &quot;&lt;pkg-name&gt;&quot;git = &quot;&lt;url&gt;&quot;rev = &quot;&lt;rev&gt;&quot;subDir = &quot;&lt;subDir&gt;&quot; 其中比如我们想要引用 Mathlib，那么就可以如下编辑 leanfile.toml 文件： 123456789101112131415name = &quot;basic&quot;version = &quot;0.1.0&quot;defaultTargets = [&quot;basic&quot;][[lean_lib]]name = &quot;Basic&quot;[[lean_exe]]name = &quot;basic&quot;root = &quot;Main&quot;[[require]]name = &quot;mathlib&quot;git = &quot;https://github.com/leanprover-community/mathlib4.git&quot;rev = &quot;v4.11.0&quot; 注意把 lean-toolchain 内容改为： 1leanprover/lean4:v4.11.0 （等价于 curl -L https://raw.githubusercontent.com/leanprover-community/mathlib4/master/lean-toolchain -o lean-toolchain） 如果你是 leanfile.lean，则在文件中添加：require mathlib from git &quot;https://github.com/leanprover-community/mathlib4&quot; 即可。 当然你也可以选择在安装项目的时候使用指令： 1lake +leanprover-community/mathlib4:lean-toolchain new &lt;your_project_name&gt; math 这时运行 lake update ，额，它就会疯狂安装包。 下面这个命令可以下载预编译的文件： 这样build就很快：","link":"2024/11/29/Lean4-0/"},{"title":"一个素数拆分成特定形式平方和的例子","text":"听说有人在催我写博客 1. x2+y2x^2+y^2x2+y2形式的素数 考虑这样一个十分经典的问题： 对于不定方程 x2+y2=px^2+y^2=px2+y2=p，其中 ppp 为正素数，那么该方程是否存在整数解？ OK，我们把问题简化一下： 对于不定方程 x2+y2≡0(modp)x^2+y^2\\equiv 0\\pmod{p}x2+y2≡0(modp)，其中 ppp 为正素数，那么该方程是否存在非平凡整数解？ 1.1 探索这样素数的必要条件（性质） 1.1.1 利用完全平方数的同余性质 先尝试几个小的素数，我们观察一下规律： 素数 存在的某组解 222 (1,1)(1,1)(1,1) 333 无解 555 (1,2)(1, 2)(1,2) 777 无解 111111 无解 131313 (2,3)(2, 3)(2,3) 171717 (1,4)(1, 4)(1,4) 191919 无解 相信这里大家已经发现一些规律了。让我们进一步进行探索。 对同余的性质比较熟悉的小伙伴会注意到，完全平方数在同余情况下会呈现一些规律，比如： 模数 可能的余数 333 000, 111 444 000, 111 555 000, 111, 444 ⋯\\cdots⋯ ⋯\\cdots⋯ 是的，我们可以看到，上述列出的小素数中，除了特殊的素数 222 ，只要 p≡3(mod4)p\\equiv 3\\pmod{4}p≡3(mod4) 我们就枚举不出解，而当然 p≡1(mod4)p\\equiv 1\\pmod{4}p≡1(mod4) 的时候，我们总是找到了一组解。 为了方便讨论，之后的 ppp 均考虑为正奇素数。 要想要排除掉 p≡3(mod4)p\\equiv 3\\pmod{4}p≡3(mod4) 这个情况其实是很容易的。只需要在方程 x2+y2=px^2 + y^2=px2+y2=p 两端同时模掉 444 ，根据前面的铺垫，可以知道 x2+y2(mod4)x^2 + y^2 \\pmod{4}x2+y2(mod4) 只会有三种取值，即 000, 111, 222，这说明对于正奇素数只可能有 p≡1(mod4)p\\equiv 1\\pmod{4}p≡1(mod4) 。 此时我们获得了正素数 p=x2+y2p=x^2+y^2p=x2+y2 有解的一个必要条件： p=2 或者 p≡1(mod4)p = 2 \\text{ 或者 } p \\equiv 1 \\pmod{4} p=2 或者 p≡1(mod4) 1.1.2 利用二次同余方程（二次剩余） 到这里有经验的伙伴就看出来，不妨设 y≠0y\\neq 0y​=0 ，把变量挪到一边那么就有： (xy−1)2=−1(modp)\\left(xy^{-1}\\right)^2=-1\\pmod{p} (xy−1)2=−1(modp) 设 z=xy−1z=xy^{-1}z=xy−1 ，那么方程就转化为： z2=−1(modp)z^2=-1\\pmod{p} z2=−1(modp) 问题即变成了，−1-1−1 是否能在 Zp\\mathbb{Z}_pZp​ 中开根号，或说 Zp\\mathbb{Z}_pZp​ 中是否有一个其平方为 −1-1−1 的元素？ 先停一停，让我们在这里插播一个同余理论中十分重要的定理： 费马小定理（Fermat’s little theorem） 对于一个素数 ppp ，如果 整数 aaa 与 ppp 互素 ，那么 ap−1≡1(modp)a^{p-1}\\equiv 1\\pmod{p}ap−1≡1(modp) 同样地也可以将特殊情况囊括进去，即对 任意整数 aaa 都有： ap≡a(modp)a^{p}\\equiv a \\pmod{p} ap≡a(modp) 如果我们把这个定理应用于 zzz ，那么就有： zp−1≡1(modp)z^{p-1}\\equiv 1\\pmod{p} zp−1≡1(modp) 同时我们先前已经假设 ppp 为奇素数，那么 p−1p-1p−1 实际上就是偶数，也就有： (z2)p−12=zp−1≡1(modp)(z^2)^{\\frac{p-1}{2}}=z^{p-1}\\equiv 1\\pmod{p} (z2)2p−1​=zp−1≡1(modp) 好的我们回到刚刚的问题，注意到两个条件 (z2)p−12=zp−1≡1(modp)(z^2)^{\\frac{p-1}{2}}=z^{p-1}\\equiv 1\\pmod{p}(z2)2p−1​=zp−1≡1(modp) 以及 z2=−1(modp)z^2=-1\\pmod{p}z2=−1(modp) ，结合起来就是： (−1)p−12≡1(modp)(-1)^{\\frac{p-1}{2}}\\equiv 1\\pmod{p} (−1)2p−1​≡1(modp) 这个等式并不总是成立，我们注意到，只有当 p−12\\frac{p-1}{2}2p−1​ 也是偶数的时候，才成立。殊途同归，我们了一个相同的必要条件： p≡1(mod4)p\\equiv 1\\pmod{4} p≡1(mod4) 走到这里其实我们其实可以更进一步，将上述 −1-1−1 考虑为更一般的整数 ttt （不为 ppp 的倍数），那么不难证明： ∃x∈Zp∗ s.t. x2≡t(modp) ⟺ tp−12≡1(modp)\\exists x\\in\\mathbb{Z}_p^{*}\\text{ s.t. } x^2\\equiv t\\pmod{p}\\iff t^{\\frac{p-1}{2}}\\equiv 1\\pmod{p}∃x∈Zp∗​ s.t. x2≡t(modp)⟺t2p−1​≡1(modp) ∄x∈Zp∗ s.t. x2≡t(modp) ⟺ tp−12≡−1(modp)\\not\\exists x\\in\\mathbb{Z}_p^{*}\\text{ s.t. } x^2\\equiv t\\pmod{p}\\iff t^{\\frac{p-1}{2}}\\equiv -1\\pmod{p}​∃x∈Zp∗​ s.t. x2≡t(modp)⟺t2p−1​≡−1(modp) （注意到由费马小定理， tp−1−1=(tp−12−1)(tp−12+1)≡0(modp)t^{p-1}-1 = \\left(t^{\\frac{p-1}{2}}-1\\right)\\left(t^{\\frac{p-1}{2}} + 1\\right)\\equiv 0\\pmod{p}tp−1−1=(t2p−1​−1)(t2p−1​+1)≡0(modp)，且 Zp\\mathbb{Z}_pZp​ 为整环） 这种判别 Zp∗\\mathbb{Z}_p^*Zp∗​ 上某个元素是否能开方的方法称为欧拉判据，而上述这样的元素开方问题称为二次剩余问题，如果在模素数 ppp 的情况下，对 t∈Zp∗t\\in\\mathbb{Z}_p^{*}t∈Zp∗​ 有 ∃x∈Zp∗ s.t. x2≡t(modp)\\exists x\\in\\mathbb{Z}_p^{*}\\text{ s.t. } x^2\\equiv t\\pmod{p}∃x∈Zp∗​ s.t. x2≡t(modp)，那么就称 ttt 为 素数 ppp 的二次剩余，否则称为二次非剩余。我们常常用勒让德符号（Legendre symbol） 来表示： 勒让德符号 (tp)={1t 是p 的二次剩余−1t 是p 的二次非剩余0t 是p 的倍数\\left( \\dfrac{t}{p} \\right) = \\begin{cases} 1 &amp; t \\text{ 是} p \\text{ 的二次剩余} \\\\ -1 &amp; t \\text{ 是} p \\text{ 的二次非剩余} \\\\ 0 &amp; t \\text{ 是} p \\text{ 的倍数} \\end{cases} (pt​)=⎩⎪⎪⎨⎪⎪⎧​1−10​t 是p 的二次剩余t 是p 的二次非剩余t 是p 的倍数​ 将上述我们所讨论的内容总结成定理，就是下面欧拉判别式： 欧拉判据 (tp)=tp−12(modp)\\left( \\dfrac{t}{p} \\right) = t^{\\frac{p-1}{2}}\\pmod{p} (pt​)=t2p−1​(modp) 当然，二次剩余的理论十分深刻，我们这里暂时就不做深刻讨论，此处不加证明地给出几个有关奇素数 ppp 勒让德符号的计算规律： （积性）若 p∤m⋅np \\not| m\\cdot np​∣m⋅n ，则有： (mp)(np)=(mnp)\\left( \\dfrac{m}{p} \\right) \\left( \\dfrac{n}{p} \\right) = \\left( \\dfrac{mn}{p} \\right)(pm​)(pn​)=(pmn​) （平移不变性） ∀k∈Z\\forall k\\in \\mathbb{Z}∀k∈Z ，总有 (kp+tp)=(tp)\\left( \\dfrac{kp+t}{p} \\right) = \\left( \\dfrac{t}{p} \\right)(pkp+t​)=(pt​) （单位元(unit)的勒让德符号） (1p)=1\\left( \\dfrac{1}{p} \\right) = 1(p1​)=1 ； (−1p)=(−1)p−12\\left( \\dfrac{-1}{p} \\right) = (-1)^{\\frac{p-1}{2}}(p−1​)=(−1)2p−1​ （偶素数的勒让德符号） (2p)=(−1)p2−18\\left( \\dfrac{2}{p} \\right) = (-1)^{\\frac{p^2-1}{8}}(p2​)=(−1)8p2−1​ （二次互反律）对两个不等的奇素数 p,qp, qp,q 有： (pq)(qp)=(−1)12(p−1)(q−1)\\left( \\dfrac{p}{q} \\right)\\left( \\dfrac{q}{p} \\right) = (-1) ^ {\\frac{1}{2}(p - 1)(q - 1)}(qp​)(pq​)=(−1)21​(p−1)(q−1) 计算应用： （利用整数标准分解计算勒让德符号） (tp)=(±1p)(2p)r(q1p)l1⋯(qsp)ls\\left( \\dfrac{t}{p} \\right) = \\left( \\dfrac{\\pm 1}{p} \\right)\\left( \\dfrac{2}{p} \\right) ^ r \\left( \\dfrac{q_ 1}{p} \\right) ^ {l_ 1} \\cdots \\left( \\dfrac{q_ s}{p} \\right) ^ {l_ s}(pt​)=(p±1​)(p2​)r(pq1​​)l1​⋯(pqs​​)ls​ 这时回到原问题 z2≡−1(modp)z^2\\equiv -1\\pmod{p}z2≡−1(modp) ，问题就很清楚了。 注：勒让德符号能一定意义上推广为雅可比符号，利用雅克比符号及其相关性质，我们可以类似于辗转相除法求得各种形如 x2≡a(modn)x^2\\equiv a\\pmod{n}x2≡a(modn) （其中这里不再要求 nnn 为奇素数）解的存在性问题。 1.1.3 构造的方法 对于这个问题，其实我们有一个构造型的结果，说明 p≡1(mod4)p\\equiv 1\\pmod{4}p≡1(mod4) 时 x2≡−1(modp)x^2\\equiv -1 \\pmod{p}x2≡−1(modp) 总是有解的。 这里还是会涉及到一个重要数论/代数定理： 威尔逊定理（Wilson’s theorem） 对于一个正整数 ppp ，有： p 为素数 ⟺ (p−1)!≡−1(modp)p \\text{ 为素数 } \\iff (p-1)!\\equiv -1\\pmod{p} p 为素数 ⟺(p−1)!≡−1(modp) 这个定理的含义可以如此理解：考虑域 Zp\\mathbb{Z}_pZp​ 上的方程 xp−1−1≡0(modp)x^{p-1} - 1 \\equiv 0\\pmod{p}xp−1−1≡0(modp) ，那么它的根就是 Zp\\mathbb{Z}_pZp​ 的所有非零元素，于是根据韦达定理有： ∏i=1p−1xi≡−1(modp) ⟺ ∏i=1p−1i≡−1(modp) ⟺ (p−1)!≡−1(modp)\\begin{aligned} \\prod_{i=1}^{p-1} x_i \\equiv -1\\pmod{p} &amp;\\iff \\prod_{i=1}^{p-1} i \\equiv -1\\pmod{p} \\\\ &amp;\\iff (p-1)!\\equiv -1\\pmod{p} \\end{aligned} i=1∏p−1​xi​≡−1(modp)​⟺i=1∏p−1​i≡−1(modp)⟺(p−1)!≡−1(modp)​ 到这里我又想多嘴一下，其实Wilson定理可以使用Sylow第三定理进行证明。 Sylow第三定理 设有限群 ∣G∣=pαm|G|=p^{\\alpha} m∣G∣=pαm ，其中 p∤mp\\not| mp​∣m ，那么 GGG 的 Sylow-p\\text{Sylow-}pSylow-p 子群（即 GGG 的 pαp^{\\alpha}pα 阶子群） 的个数 NpN_pNp​ 满足： Np=[G:NG(P)]N_p = \\left[ G:N_G(P) \\right]Np​=[G:NG​(P)] Np≡1(modp)N_p\\equiv 1\\pmod{p}Np​≡1(modp) Np∣mN_p\\mid mNp​∣m 其中 NG(P)={g∈G∣gPg−1=P}N_G(P)=\\left\\{ g\\in G\\mid gPg^{-1}=P \\right\\}NG​(P)={g∈G∣gPg−1=P} 为 PPP 在 GGG 中的正规化子。 对整数 ppp ，考虑置换群 SpS_pSp​ 的 Sylow-p\\text{Sylow-}pSylow-p 子群，注意到 ∣Sp∣=p!|S_p|=p!∣Sp​∣=p!。 若 ppp 为素数，那么 SpS_pSp​ 的 Sylow-p\\text{Sylow-}pSylow-p 子群的阶恰好为 ppp，从而 SpS_pSp​ 的 Sylow-p\\text{Sylow-}pSylow-p 子群恰为各个不同 ppp-循环生成的循环子群，这样的子群全体记为 Sylp(Sp)\\text{Syl}_p(S_p)Sylp​(Sp​)，容易知道 SpS_pSp​ 的 Sylow-p\\text{Sylow-}pSylow-p 子群个数 Np=∣Sylp(Sp)∣=p!p⋅(p−1)=(p−2)!N_p = |\\text{Syl}_p(S_p)|=\\dfrac{p!}{p \\cdot (p-1)} = (p-2)!Np​=∣Sylp​(Sp​)∣=p⋅(p−1)p!​=(p−2)! （除以的 ppp 是注意到 (i1 i2 ⋯ ip)(i_1\\ i_2\\ \\cdots\\ i_p)(i1​ i2​ ⋯ ip​) 与 (i2 i3 ⋯ ip i1)(i_2\\ i_3\\ \\cdots\\ i_p\\ i_1)(i2​ i3​ ⋯ ip​ i1​)是等价的；除以的 (p−1)(p-1)(p−1) 是因为循环群的阶数是 (p−1)(p-1)(p−1)）。 从而根据 Sylow第三定理： (p−2)!≡1(modp)(p-2)!\\equiv 1\\pmod p (p−2)!≡1(modp) 即 (p−1)!≡p−1≡−1(modp)(p-1)!\\equiv p-1\\equiv -1\\pmod{p} (p−1)!≡p−1≡−1(modp) 若 ppp 不是素数，那么 ∣Sylp(Sp)∣≠(p−2)!|\\text{Syl}_p(S_p)|\\neq (p-2)!∣Sylp​(Sp​)∣​=(p−2)!，具体请读着自行计算。 现在回到我们的问题上，考虑 p=4k+1p=4k+1p=4k+1 的情形。 注意到由Wilson定理： (4k)!≡−1(modp)(4k)!\\equiv -1\\pmod{p} (4k)!≡−1(modp) 即： (4k)!≡−1(mod4k+1) ⟺ (4k)⋯(2k+1)⋅(2k)!≡−1(mod4k+1) ⟺ (−1)⋯(−2k)⋅(2k)!≡−1(mod4k+1) ⟺ (−1)2k⋅((2k)!)2≡−1(mod4k+1) ⟺ ((2k)!)2≡−1(mod4k+1)\\begin{aligned} &amp;(4k)!\\equiv -1\\pmod{4k+1}\\\\ \\iff &amp;(4k)\\cdots(2k+1) \\cdot (2k)! \\equiv -1\\pmod{4k+1}\\\\ \\iff &amp;(-1)\\cdots(-2k) \\cdot (2k)! \\equiv -1\\pmod{4k+1}\\\\ \\iff &amp;(-1)^{2k} \\cdot \\left((2k)!\\right)^2 \\equiv -1\\pmod{4k+1}\\\\ \\iff &amp;\\left((2k)!\\right)^2 \\equiv -1\\pmod{4k+1} \\end{aligned} ⟺⟺⟺⟺​(4k)!≡−1(mod4k+1)(4k)⋯(2k+1)⋅(2k)!≡−1(mod4k+1)(−1)⋯(−2k)⋅(2k)!≡−1(mod4k+1)(−1)2k⋅((2k)!)2≡−1(mod4k+1)((2k)!)2≡−1(mod4k+1)​ 即取 x=2k!x=2k!x=2k! ，即可。 1.2 必要条件是否充分？ 我们花了很多时间来讨论 $ x^2 + y^2 \\equiv 0\\ p $ 的解的情况 1.2.1 数论的方法 1.2.2 几何（格）的方法 1.3. 一个例子：x2+xy+y2x^2 + xy + y^2x2+xy+y2 形式的素数","link":"2024/10/08/p=x2+ny2/"}],"tags":[{"name":"Lean4","slug":"Lean4","link":"tags/Lean4/"},{"name":"NumberTheory","slug":"NumberTheory","link":"tags/NumberTheory/"}],"categories":[]}