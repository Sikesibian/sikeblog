<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>Rust 实现（一个弱智的）大整数计算 · Sikesibian's Blog</title><meta name="description" content="后续：这个代码发现还是有不少问题的，但是博主很懒，所以有空再把调整后的代码放上来吧~

前天学习了如何使用 rust，想随便写点东西练练手，就想着写一个简单的 Math Repl 吧。这是第一版（对的，还有第零版）的某个数学运算组件，正好没考虑效率地写完了可以进行测试，于是就有了这篇博客。

背景故"><meta name="keywords" content="Coding,Rust"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="mobile-web-app-capable" content="yes"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta id="site_data_static" data-url="/"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/"><link rel="stylesheet" href="/js_complied/bundle.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""><script src="/js_complied/bundle.js"></script><script>Utils.loadCSS("https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@200..900&family=Noto+Serif+KR:wght@200..900&family=Noto+Serif+SC:wght@200..900&family=Noto+Serif+TC:wght@200..900&family=Noto+Serif:ital,wght@0,100..900;1,100..900&display=swap");
Utils.loadCSS("https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css");
Utils.loadCSS("/css/font-awesome.min.css");</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 8.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body class="post-page"><noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@200..900&amp;family=Noto+Serif+KR:wght@200..900&amp;family=Noto+Serif+SC:wght@200..900&amp;family=Noto+Serif+TC:wght@200..900&amp;family=Noto+Serif:ital,wght@0,100..900;1,100..900&amp;display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"></noscript><nav class="nav"><a href="/">首页</a>&nbsp;&nbsp;<a href="/archives">归档</a>&nbsp;&nbsp;<a href="/tags">标签</a>&nbsp;&nbsp;<a href="/search">搜索</a></nav><div class="main"><div class="post-container post-full"><div class="post-title"><h1>Rust 实现（一个弱智的）大整数计算</h1></div><div class="post-body"><blockquote>
<p><strong>后续</strong>：这个代码发现还是有不少问题的，但是博主很懒，所以有空再把调整后的代码放上来吧~</p>
</blockquote>
<p><strong>前天</strong>学习了如何使用 rust，想随便写点东西练练手，就想着写一个简单的 Math Repl 吧。这是第一版（对的，还有第零版）的某个数学运算组件，正好没考虑效率地写完了可以进行测试，于是就有了这篇博客。</p>
<blockquote>
<p><strong>背景故事：第零版写着写着就开始在从头写定制的解释器（仅仅到条件语句），写到 <code>AST</code> 就破防了，感觉很笨重而且估计有些问题（虽然设定的一些测试过了），拼尽全力无法战胜（懒惰）于是第一版转战使用 <code>pest</code> ，舒服多了，但是需要先实现一下大整数计算，遂生此博客。</strong></p>
</blockquote>
<h2 id="定义bigint结构体">定义BigInt结构体</h2>
<p>定义一个 <code>BigInt</code> 结构体来表示大整数。这个结构体包含一个 <code>Vec&lt;i64&gt;</code> 类型的字段 <code>digits</code>，用于存储大整数的各个位数。从低位到高位动态存储。</p>
<pre><code class="language-rust">use std::cmp::Ordering;
use std::ops::{Add, Sub, Mul, Div, Rem, Neg};

use fraction::Fraction;

const BASE: i64 = 10;

#[derive(Debug, Clone)]
pub struct BigInt {
    digits: Vec&lt;i64&gt;,
    sign: bool, // false: positive, true: negative
}

impl BigInt {
    pub fn new(mut digits: Vec&lt;i64&gt;, sign: bool) -&gt; Self {
        while digits.len() &gt; 1 &amp;&amp; digits.last() == Some(&amp;0) {
            digits.pop();
        }
        BigInt { digits, sign }
    }

    pub fn to_string(&amp;self) -&gt; String{
        let sign = if self.sign { &quot;-&quot; } else { &quot;&quot; };
        let digits = self.digits.iter().rev().map(|&amp;x| x.to_string()).collect::&lt;Vec&lt;_&gt;&gt;().join(&quot;&quot;);
        format!(&quot;{}{}&quot;, sign, digits)
    }
}
</code></pre>
<h2 id="实现基本运算">实现基本运算</h2>
<h3 id="比较运算-partialeq-eq-partialord-和-ord-比较大整数">比较运算，<code>PartialEq</code>、<code>Eq</code>、<code>PartialOrd</code> 和 <code>Ord</code> 比较大整数。</h3>
<pre><code class="language-rust">impl PartialEq for BigInt {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        (self.digits == other.digits &amp;&amp; self.sign == other.sign) ||
        (self.is_zero() &amp;&amp; other.is_zero())
    }
    fn ne(&amp;self, other: &amp;Self) -&gt; bool {
        !self.eq(other)
    }
}

impl Eq for BigInt {}

impl PartialOrd for BigInt {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        if self.sign != other.sign {
            return Some(if self.sign { Ordering::Less } else { Ordering::Greater });
        }
        if self.digits.len() != other.digits.len() {
            return Some(self.digits.len().cmp(&amp;other.digits.len()));
        }
        Some(self.cmp(other))
    }
}

impl Ord for BigInt {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        if self.sign != other.sign {
            return if self.sign { Ordering::Less } else { Ordering::Greater };
        }
        let len_cmp = self.digits.len().cmp(&amp;other.digits.len());
        if len_cmp != Ordering::Equal {
            return len_cmp;
        }
        for (a, b) in self.digits.iter().rev().zip(other.digits.iter().rev()) {
            let cmp = a.cmp(b);
            if cmp != Ordering::Equal {
                return cmp;
            }
        }
        Ordering::Equal
    }
}
</code></pre>
<h3 id="从string类型转换为bigint">从<code>String</code>类型转换为<code>BigInt</code>。</h3>
<pre><code class="language-rust">impl From&lt;String&gt; for BigInt {
    fn from(mut s: String) -&gt; Self {
        let mut digits = Vec::new();
        // remove zero
        while s.starts_with('0') &amp;&amp; s.len() &gt; 1 {
            s.remove(0);
        }
        for c in s.chars() {
            digits.push(c.to_digit(10).unwrap() as i64);
        }
        digits.reverse();
        BigInt { digits, sign: false }
    }
}
</code></pre>
<h3 id="相反数运算">相反数运算</h3>
<pre><code class="language-rust">impl Neg for BigInt {
    type Output = Self;
    fn neg(self) -&gt; Self {
        BigInt { digits: self.digits, sign: !self.sign }
    }
}
</code></pre>
<h3 id="加法运算">加法运算</h3>
<pre><code class="language-rust">impl Add for BigInt {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        if self.sign != other.sign {
            if self.digits == other.digits {
                return BigInt::zero();
            }
            return self - (-other);
        }
        let mut result = Vec::new();
        let mut carry = 0;
        let max_len = self.digits.len().max(other.digits.len());

        for i in 0..max_len {
            let a = *self.digits.get(i).unwrap_or(&amp;0);
            let b = *other.digits.get(i).unwrap_or(&amp;0);
            let sum = a + b + carry;
            result.push(sum % BASE);
            carry = sum / BASE;
        }

        if carry &gt; 0 {
            result.push(carry);
        }

        while result.len() &gt; 1 &amp;&amp; result.last() == Some(&amp;0) {
            result.pop();
        }

        BigInt { digits: result , sign: self.sign }
    }
}
</code></pre>
<h3 id="减法运算">减法运算</h3>
<pre><code class="language-rust">impl Sub for BigInt {
    type Output = Self;

    fn sub(self, other: Self) -&gt; Self {
        if self.sign == other.sign &amp;&amp; self.digits == other.digits {
            return BigInt::zero();
        }
        if self.sign != other.sign {
            return self + (-other);
        }
        let mut result = Vec::new();
        let mut borrow = 0;
        let mut sign = self.sign;
        let (larger, smaller) = if self &gt;= other {
            (self, other)
        } else {
            sign = !self.sign;
            (other, self)
        };

        for i in 0..larger.digits.len() {
            let a = *larger.digits.get(i).unwrap_or(&amp;0);
            let b = *smaller.digits.get(i).unwrap_or(&amp;0);
            let mut diff = a - b - borrow;
            if diff &lt; 0 {
                diff += BASE;
                borrow = 1;
            } else {
                borrow = 0;
            }
            result.push(diff);
        }

        while result.len() &gt; 1 &amp;&amp; result.last() == Some(&amp;0) {
            result.pop();
        }

        BigInt { digits: result, sign }
    }
}
</code></pre>
<h3 id="乘法运算">乘法运算</h3>
<pre><code class="language-rust">impl Mul for BigInt {
    type Output = Self;

    fn mul(self, other: Self) -&gt; Self {
        let mut result = vec![0; self.digits.len() + other.digits.len()];

        for (i, &amp;a) in self.digits.iter().enumerate() {
            let mut carry = 0;
            for (j, &amp;b) in other.digits.iter().enumerate() {
            let sum = result[i + j] + a * b + carry;
            result[i + j] = sum % BASE;
            carry = sum / BASE;
            }
            result[i + other.digits.len()] += carry;
        }

        while result.len() &gt; 1 &amp;&amp; result.last() == Some(&amp;0) {
            result.pop();
        }

        BigInt { digits: result, sign: self.sign ^ other.sign }
    }
}
</code></pre>
<h3 id="除法运算">除法运算</h3>
<pre><code class="language-rust">impl Div for BigInt {
    type Output = Self;

    fn div(self, other: Self) -&gt; Self {
        if other.digits.is_empty() || other.is_zero() {
            eprintln!(&quot;Warning: Division by zero&quot;);
            return BigInt::zero();
        }
        let mut remainder = self.clone().abs();
        let mut quotient = BigInt { digits: vec![], sign: self.sign ^ other.sign };
        let mut divisor = other.abs();
        if remainder &lt; divisor {
            return BigInt { digits: vec![0], sign: self.sign };
        }
        let divisor_len = divisor.digits.len();
        while divisor.digits.len() &lt; remainder.digits.len() {
            divisor.digits.insert(0, 0);
        }
        while divisor.digits.len() &gt;= divisor_len {
            let mut quotient_digit = 0;
            while remainder &gt;= divisor {
                remainder = remainder - divisor.clone();
                quotient_digit += 1;
            }
            quotient.digits.insert(0, quotient_digit);
            divisor.digits.remove(0);
        }
        
        while quotient.digits.len() &gt; 1 &amp;&amp; quotient.digits.last() == Some(&amp;0) {
            quotient.digits.pop();
        }

        quotient
    }
}
</code></pre>
<h3 id="取余运算">取余运算</h3>
<pre><code class="language-rust">impl Rem for BigInt {
    type Output = Self;

    fn rem(self, other: Self) -&gt; Self {
        if other.digits.is_empty() || other.is_zero() {
            eprintln!(&quot;Warning: Division by zero&quot;);
            return BigInt::zero();
        }
        if other.sign {
            eprintln!(&quot;Warning: The moduli cannot be negative!&quot;);
            return BigInt::zero();
        }
        let mut remainder = self.clone().abs();
        let mut divisor = other.clone().abs();
        if remainder &lt; divisor {
            if self.sign &amp;&amp; !remainder.is_zero() {
                remainder = other.abs() - remainder;
            }
            return remainder;
        }
        let divisor_len = divisor.digits.len();
        while divisor.digits.len() &lt; remainder.digits.len() {
            divisor.digits.insert(0, 0);
        }
        while divisor.digits.len() &gt;= divisor_len {
            while remainder &gt;= divisor {
                remainder = remainder - divisor.clone();
            }
            divisor.digits.remove(0);
        }

        if self.sign &amp;&amp; !remainder.is_zero() {
            remainder = other.abs() - remainder;
        }
        remainder
    }
}
</code></pre>
<h2 id="其他">其他</h2>
<p>还为<code>BigInt</code>实现了一些其他有用的方法，例如<strong>幂运算、模幂运算、判断是否为零、判断是否为一、判断是否为负数、计算最大公约数（方便约分）、取绝对值和阶乘等等</strong>。</p>
<pre><code class="language-rust">impl BigInt {
    pub fn zero() -&gt; Self {
        BigInt { digits: vec![0], sign: false }
    }
    pub fn one() -&gt; Self {
        BigInt { digits: vec![1], sign: false }
    }
}

impl BigInt {
    pub fn fraction(self, other: Self) -&gt; Fraction {
        if other.digits.is_empty() || other.is_zero() {
            eprintln!(&quot;Warning: Division by zero&quot;);
            return Fraction::zero();
        }
        return Fraction::new(self, other);
    }

    pub fn pow(self, exp: u32) -&gt; Self {
        let mut base = self;
        let mut exp = exp;
        let mut result = BigInt::one();

        while exp &gt; 0 {
            if exp % 2 == 1 {
            result = result * base.clone();
            }
            base = base.clone() * base;
            exp /= 2;
        }

        result
    }

    pub fn mod_pow(self, exp: u32, modulus: Self) -&gt; Self {
        if modulus.digits.is_empty() || (modulus.digits.len() == 1 &amp;&amp; modulus.digits[0] == 0) {
            panic!(&quot;Modulus cannot be zero&quot;);
        }
        let mut base = self % modulus.clone();
        let mut exp = exp;
        let mut result = BigInt::one() % modulus.clone();
        while exp &gt; 0 {
            if exp % 2 == 1 {
                result = (result * base.clone()) % modulus.clone();
            }
            base = (base.clone() * base) % modulus.clone();
            exp /= 2;
        }
        
        result
    }

    pub fn is_zero(&amp;self) -&gt; bool {
        self.digits.is_empty() || (self.digits.len() == 1 &amp;&amp; self.digits[0] == 0)
    }

    pub fn is_one(&amp;self) -&gt; bool {
        self.digits.len() == 1 &amp;&amp; self.digits[0] == 1
    }

    pub fn is_negative(&amp;self) -&gt; bool {
        self.digits.first().map_or(false, |&amp;digit| digit &lt; 0)
    }

    pub fn gcd(&amp;self, other: &amp;Self) -&gt; Self {
        let mut a = self.clone().abs();
        let mut b = other.clone().abs();

        while !b.is_zero() {
            let temp = b.clone();
            b = a % b;
            a = temp;
        }

        a
    }

    pub fn abs(mut self) -&gt; Self {
        self.sign = false;
        self
    }

    pub fn factorial(self) -&gt; Self {
        if self.is_negative() {
            eprintln!(&quot;Warning: Factorial of a negative number is undefined&quot;);
            return BigInt::zero();
        }
        let mut result = BigInt::one();
        let mut i = BigInt::one();
        while i &lt;= self.clone() {
            result = result * i.clone();
            i = i + BigInt::one();
        }
        result
    }
}
</code></pre>
<h2 id="测试">测试</h2>
<p>编写了一些测试用例来验证<code>BigInt</code>的各种功能。</p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use crate::backend::bigint::BigInt;

    #[test]
    fn test_creation() {
        let bigint = BigInt { digits: vec![1, 2, 3], sign: false };
        assert_eq!(bigint.digits, vec![1, 2, 3]);
    }

    #[test]
    fn test_comparison() {
        let a = BigInt { digits: vec![1, 2, 3], sign: false };
        let b = BigInt { digits: vec![1, 2, 3], sign: false };
        assert_eq!(a, b);
        let c = BigInt { digits: vec![1, 2, 4], sign: false };
        assert_ne!(a, c);
        assert!(a &lt; c);
        let d = BigInt { digits: vec![1, 9], sign: false };
        assert!(a &gt; d);
        let e = BigInt { digits: vec![1, 2, 3], sign: true };
        assert!(e &lt; a);
    }

    #[test]
    fn test_negation() {
        let a = BigInt { digits: vec![1, 2, 3], sign: false };
        let result = -a;
        assert_eq!(result.digits, vec![1, 2, 3]);
        assert_eq!(result.sign, true);
    }

    #[test]
    fn test_addition() {
        let a = BigInt { digits: vec![6, 2, 3], sign: false };
        let b = BigInt { digits: vec![4, 5, 6], sign: false };
        let result = a + b;
        assert_eq!(result.digits, vec![0, 8, 9]);
        assert_eq!(result.sign, false);
        let d = BigInt { digits: vec![1, 2, 3], sign: false };
        let c = BigInt { digits: vec![1, 2, 3], sign: true };
        let result = d + c;
        assert_eq!(result, BigInt::zero());
        let e = BigInt { digits: vec![1, 2, 3], sign: true };
        let f = BigInt { digits: vec![1, 2, 2], sign: false };
        let result = e + f;
        assert_eq!(result.digits, vec![0, 0, 1]);
        assert_eq!(result.sign, true);
    }

    #[test]
    fn test_subtraction() {
        let a = BigInt { digits: vec![5, 1, 9], sign: false };
        let b = BigInt { digits: vec![1, 2, 3], sign: false };
        let result = a - b;
        assert_eq!(result.digits, vec![4, 9, 5]);
        assert_eq!(result.sign, false);
        let a = BigInt { digits: vec![1, 2, 3], sign: false };
        let b = BigInt { digits: vec![5, 1, 9], sign: false };
        let result = a - b;
        assert_eq!(result.digits, vec![4, 9, 5]);
        assert_eq!(result.sign, true);
        let a = BigInt { digits: vec![1, 2, 3], sign: true };
        let b = BigInt { digits: vec![1, 2, 3], sign: false };
        let result = a - b;
        assert_eq!(result.digits, vec![2, 4, 6]);
        assert_eq!(result.sign, true);
        let a = BigInt { digits: vec![1, 2, 3], sign: false };
        let b = BigInt { digits: vec![1, 3, 3], sign: false };
        let result = a - b;
        assert_eq!(result.digits, vec![0, 1]);
        assert_eq!(result.sign, true);
    }

    #[test]
    fn test_multiplication() {
        let a = BigInt { digits: vec![1, 2, 3], sign: false };
        let b = BigInt { digits: vec![4, 5, 6], sign: false };
        let result = a * b;
        assert_eq!(result.digits, vec![4, 3, 9, 9, 0, 2]);
        assert_eq!(result.sign, false);
        let a = BigInt { digits: vec![1, 2, 3], sign: true };
        let b = BigInt { digits: vec![4, 5, 6], sign: false };
        let result = a * b;
        assert_eq!(result.digits, vec![4, 3, 9, 9, 0, 2]);
        assert_eq!(result.sign, true);
    }

    #[test]
    fn test_division() {
        let a = BigInt { digits: vec![1, 2, 3], sign: false };
        let b = BigInt { digits: vec![3], sign: false };
        let result = a / b;
        assert_eq!(result.digits, vec![7, 0, 1]);
        assert_eq!(result.sign, false);

        let a = BigInt { digits: vec![1, 2, 3], sign: true };
        let b = BigInt { digits: vec![4], sign: false };
        let result = a / b;
        assert_eq!(result.digits, vec![0, 8]);
        assert_eq!(result.sign, true);

        // let a = BigInt { digits: vec![1, 2, 3], sign: false };
        // let b = BigInt { digits: vec![0], sign: false };
        // let result = a / b;
        // println!(&quot;{:?}&quot;, result);
    }

    #[test]
    fn test_remainder() {
        let a = BigInt { digits: vec![1, 2, 3], sign: false };
        let b = BigInt { digits: vec![1, 2], sign: false };
        let result = a % b;
        assert_eq!(result.digits, vec![6]);
        let c = BigInt { digits: vec![1, 2, 4], sign: false };
        let a = BigInt { digits: vec![1, 2, 3], sign: false };
        let result = c % a;
        assert_eq!(result.digits, vec![0, 0, 1]);
        let d = BigInt { digits: vec![1, 2, 3], sign: true };
        let e = BigInt { digits: vec![1, 2, 3], sign: false };
        let result = d % e;
        assert_eq!(result.digits, vec![0]);
        let d = BigInt { digits: vec![1, 2, 4], sign: true };
        let e = BigInt { digits: vec![1, 2, 3], sign: false };
        let result = d % e;
        assert_eq!(result.digits, vec![1, 2, 2]);
        assert_eq!(result.sign, false);
    }

    #[test]
    fn test_pow() {
        let a = BigInt { digits: vec![2, 2], sign: false };
        let result = a.pow(3);
        assert_eq!(result.digits, vec![8, 4, 6, 0, 1]);
        assert_eq!(result.sign, false);
        let a = BigInt { digits: vec![2, 2], sign: true };
        let result = a.pow(3);
        assert_eq!(result.digits, vec![8, 4, 6, 0, 1]);
        assert_eq!(result.sign, true);
    }

    #[test]
    fn test_mod_pow() {
        let a = BigInt { digits: vec![2, 1], sign: false };
        let b = BigInt { digits: vec![9, 9], sign: false };
        let result = a.mod_pow(3, b);
        assert_eq!(result.digits, vec![5, 4]);
        assert_eq!(result.sign, false);
        let a = BigInt { digits: vec![2, 1], sign: true };
        let b = BigInt { digits: vec![9, 9], sign: false };
        let result = a.mod_pow(3, b);
        assert_eq!(result.digits, vec![4, 5]);
        assert_eq!(result.sign, false);
    }

    #[test]
    fn test_is_zero() {
        let a = BigInt { digits: vec![0], sign: false };
        assert!(a.is_zero());

        let b = BigInt { digits: vec![1], sign: false };
        assert!(!b.is_zero());
    }

    #[test]
    fn test_is_one() {
        let a = BigInt { digits: vec![1], sign: false };
        assert!(a.is_one());

        let b = BigInt { digits: vec![0], sign: false };
        assert!(!b.is_one());
    }

    #[test]
    fn test_is_negative() {
        let a = BigInt { digits: vec![-1], sign: false };
        assert!(a.is_negative());

        let b = BigInt { digits: vec![1], sign: false };
        assert!(!b.is_negative());
    }

    #[test]
    fn test_gcd() {
        let a = BigInt { digits: vec![2, 2], sign: false };
        let b = BigInt { digits: vec![3, 3], sign: false };
        let result = a.gcd(&amp;b);
        assert_eq!(result.digits, vec![1, 1]);
        assert_eq!(result.sign, false);
        let a = BigInt { digits: vec![3, 3], sign: true };
        let b = BigInt { digits: vec![2, 2], sign: false };
        let result = a.gcd(&amp;b);
        assert_eq!(result.digits, vec![1, 1]);
        assert_eq!(result.sign, false);
        let a = BigInt { digits: vec![3, 3], sign: true };
        let b = BigInt { digits: vec![3, 3], sign: false };
        let result = a.gcd(&amp;b);
        assert_eq!(result.digits, vec![3, 3]);
        assert_eq!(result.sign, false);
    }

    #[test]
    fn test_abs() {
        let a = BigInt { digits: vec![1, 2, 3], sign: false };
        let result = a.abs();
        assert_eq!(result.digits, vec![1, 2, 3]);
        assert_eq!(result.sign, false);

        let b = BigInt { digits: vec![1, 2, 3], sign: true };
        let result = b.abs();
        assert_eq!(result.digits, vec![1, 2, 3]);
        assert_eq!(result.sign, false);
    }

    #[test]
    fn test_comparison_with_zero() {
        let a = BigInt { digits: vec![1, 2, 3], sign: false };
        let b = BigInt { digits: vec![0], sign: false };
        assert!(a &gt; b);
    }

    #[test]
    fn test_comparison_with_negative_zero() {
        let a = BigInt { digits: vec![0], sign: false };
        let b = BigInt { digits: vec![-0], sign: false };
        assert!(a == b);
    }

    #[test]
    fn test_from_str() {
        let a = BigInt::from(&quot;123&quot;.to_string());
        assert_eq!(a.digits, vec![3, 2, 1]);

        let b = BigInt::from(&quot;00123&quot;.to_string());
        assert_eq!(b.digits, vec![3, 2, 1]);

        let c = BigInt::from(&quot;0&quot;.to_string());
        assert_eq!(c.digits, vec![0]);

        let d = BigInt::from(&quot;0000&quot;.to_string());
        assert_eq!(d.digits, vec![0]);

        let e = BigInt::from(&quot;9876543210&quot;.to_string());
        assert_eq!(e.digits, vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
    }

    #[test]
    fn test_factorial() {
        let a = BigInt { digits: vec![0, 1], sign: false };
        let result = a.factorial();
        println!(&quot;{}&quot;, result.to_string());
    }
}
</code></pre>
<p>测试结果：</p>
<p><img src="/img/rust-1/1734896451810.png" alt="1734896451810"></p>
</div><div class="post-meta"><span class="info"><i class="fa fa-calendar"></i> <span class="date">2024-12-23</span>  </span><span class="info"><i class="fa fa-tag"></i> <a href="/tags/Coding/" title="Coding">Coding</a>  </span><span class="info"><i class="fa fa-tag"></i> <a href="/tags/Rust/" title="Rust">Rust</a>  </span></div></div><p class="pagination"><a href="/2024/12/24/rust-2/" title="手搓的简易基于 rust 的自己设计数学语言的解释器，很爽！">上一篇</a><span>  </span><a href="/2024/12/20/rust-0/" title="Rust 安装过程中遇到的一些小问题">下一篇</a></p></div><footer class="footer"><br><p>Comment Allez Vous!</p></footer></body></html>